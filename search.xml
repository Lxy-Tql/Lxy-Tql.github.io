<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 luoguP3722 【[AHOI2017&HNOI2017]影魔】]]></title>
    <url>%2F2020%2F06%2F06%2F%E9%A2%98%E8%A7%A3%20luoguP3722%20%E3%80%90%5BAHOI2017%26HNOI2017%5D%E5%BD%B1%E9%AD%94%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 首先整个序列是一个排列，这是一个很重要的性质 考虑$(i,j)$什么时候会产生贡献： 当$k_i,k_j$为区间$(i,j)$的最大值和次大值，贡献为$p1$ 当$k_i,k_j$其中一个为区间最大值，另一个不是次大值，贡献为$p2$ 维护出每个$i$位置左边右边第一个比它大的位置，记作$L_i,R_i$，这个可以用单调栈求。于是$(L_i,R_i)$，$(i,i+1)$的贡献为$p1$，$(L_i+1…i-1,R_i)$，$(L_i,i+1…R_i-1)$的贡献为$p2$ 可以发现如果有$(p,q)$满足$p&lt;L_i,q&lt;R_i$，$(p,q)$如果有贡献，则会算在另一个$i$上，所以不会算重 对于$(i,i+1)$，直接根据询问区间长度算贡献 对于$(L_i,R_i)$，我们在枚举到$R_i$时在$L_i$上加上贡献 对于$(L_i+1…i-1,R_i)$，我们在枚举到$R_i$时在$L_i+1…i-1$这段区间加上贡献 对于$(L_i,i+1…R_i)$，同上一条 回答一个询问$[a,b]$时，如果在枚举到$b$时直接求$[a,b]$的区间和，会存在一些$(i,j)$满足$i&lt;a,a&lt;j&lt;b$的不合法的贡献。所以我们需要减去枚举到$a-1$时$[a,b]$的区间和，这样有贡献的$(i,j)$就都在区间内 $Code Below$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar#define ls(x) ((x)&lt;&lt;1)#define rs(x) ((x)&lt;&lt;1|1)//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=200005;int n,m,p1,p2,a[N],st[N],top,L[N],R[N],cnt,tot;int tr[N&lt;&lt;2],tag[N&lt;&lt;2],ans[N];struct que&#123; int x,l,r,v,id; friend bool operator &lt; (que A,que B)&#123; return A.x&lt;B.x; &#125;&#125;q[N&lt;&lt;1];struct ope&#123; int x,l,r,v; friend bool operator &lt; (ope A,ope B)&#123; return A.x&lt;B.x; &#125;&#125;op[N&lt;&lt;2];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;void push_down(int l,int r,int k)&#123; int mid=(l+r)&gt;&gt;1; tag[ls(k)]+=tag[k]; tag[rs(k)]+=tag[k]; tr[ls(k)]+=tag[k]*(mid-l+1); tr[rs(k)]+=tag[k]*(r-mid); tag[k]=0;&#125;void update(int l,int r,int x,int y,int v,int k)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)&#123; tr[k]+=(r-l+1)*v; tag[k]+=v; return; &#125; push_down(l,r,k); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,x,y,v,ls(k)); if(mid+1&lt;=y) update(mid+1,r,x,y,v,rs(k)); tr[k]=tr[ls(k)]+tr[rs(k)];&#125;int query(int l,int r,int x,int y,int k)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) return tr[k]; push_down(l,r,k); int mid=(l+r)&gt;&gt;1,res=0; if(x&lt;=mid) res+=query(l,mid,x,y,ls(k)); if(mid+1&lt;=y) res+=query(mid+1,r,x,y,rs(k)); return res;&#125;signed main()&#123; n=read(),m=read(),p1=read(),p2=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); st[top=0]=0; for(int i=1;i&lt;=n;i++)&#123; while(top&amp;&amp;a[i]&gt;a[st[top]]) top--; L[i]=st[top];st[++top]=i; &#125; st[top=0]=n+1; for(int i=n;i&gt;=1;i--)&#123; while(top&amp;&amp;a[i]&gt;a[st[top]]) top--; R[i]=st[top];st[++top]=i; &#125; for(int i=1;i&lt;=m;i++)&#123; int l=read(),r=read();ans[i]=(r-l)*p1;//(i,i+1)的贡献 q[++cnt]=(que)&#123;l-1,l,r,-1,i&#125;; q[++cnt]=(que)&#123;r,l,r,1,i&#125;; &#125; sort(q+1,q+cnt+1); for(int i=1;i&lt;=n;i++)&#123; if(L[i]&gt;=1&amp;&amp;R[i]&lt;=n) op[++tot]=(ope)&#123;R[i],L[i],L[i],p1&#125;; if(L[i]&gt;=1&amp;&amp;R[i]-1&gt;=i+1) op[++tot]=(ope)&#123;L[i],i+1,R[i]-1,p2&#125;; if(L[i]+1&lt;=i-1&amp;&amp;R[i]&lt;=n) op[++tot]=(ope)&#123;R[i],L[i]+1,i-1,p2&#125;; &#125; sort(op+1,op+tot+1); for(int i=1,j=1;i&lt;=cnt;i++)&#123; while(j&lt;=tot&amp;&amp;op[j].x&lt;=q[i].x)&#123; update(1,n,op[j].l,op[j].r,op[j].v,1); j++; &#125; ans[q[i].id]+=q[i].v*query(1,n,q[i].l,q[i].r,1); &#125; for(int i=1;i&lt;=m;i++) writeln(ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>Luogu</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1067A 【Array Without Local Maximums】]]></title>
    <url>%2F2019%2F12%2F19%2F%E9%A2%98%E8%A7%A3%20CF1067A%20%E3%80%90Array%20Without%20Local%20Maximums%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 记$f[i][j][0/1]$表示前$i$个数，第$i$个数取$j$，左边一个数是否大于等于这个数（满足条件为$1$，否则为$0$）的方案数。 转移时，如果这一位为$-1$，枚举这一位的数字$1\sim200$，枚举上一位的数字$1\sim 200$转移。 代码如下：1234567for(int j=1;j&lt;=200;j++)&#123;//当前位 for(int k=1;k&lt;=200;k++)&#123;//上一位 if(k==j) f[i][j][1]=(f[i][j][1]+f[i-1][k][0]+f[i-1][k][1])%mo; if(k&gt;j) f[i][j][1]=(f[i][j][1]+f[i-1][k][1])%mo; if(k&lt;j) f[i][j][0]=(f[i][j][0]+f[i-1][k][0]+f[i-1][k][1])%mo; &#125; &#125; 如果这一位不为$-1$，省去当前位的枚举。 可以发现这样转移是$O(40000\times n)$的，无法通过。 观察到从上一位转移过来的$f[i-1][k][0/1]$是连续的一段，那么前缀和优化即可。 复杂度$O(200\times n)$。 我为什么要写这么水的题的题解？？既然写了那就交吧。 $Code\ Below:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar#define mo 998244353//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=100005,M=205;int n,a[N],f[N][M][2],ans,pre[M][2],suf[M][2];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); if(a[1]==-1) for(int i=1;i&lt;=200;i++) f[1][i][0]=1; else f[1][a[1]][0]=1; for(int j=1;j&lt;=200;j++)&#123; pre[j][0]=(pre[j-1][0]+f[1][j][0])%mo; pre[j][1]=(pre[j-1][1]+f[1][j][1])%mo; &#125; for(int j=200;j&gt;=1;j--)&#123; suf[j][0]=(suf[j+1][0]+f[1][j][0])%mo; suf[j][1]=(suf[j+1][1]+f[1][j][1])%mo; &#125; for(int i=2;i&lt;=n;i++)&#123; if(a[i]==-1)&#123; for(int j=1;j&lt;=200;j++)&#123; f[i][j][1]=(f[i][j][1]+f[i-1][j][0]+f[i-1][j][1])%mo; f[i][j][1]=(f[i][j][1]+suf[j+1][1])%mo; f[i][j][0]=(f[i][j][0]+pre[j-1][0]+pre[j-1][1])%mo; &#125; &#125; else&#123; f[i][a[i]][1]=(f[i][a[i]][1]+f[i-1][a[i]][0]+f[i-1][a[i]][1])%mo; f[i][a[i]][1]=(f[i][a[i]][1]+suf[a[i]+1][1])%mo; f[i][a[i]][0]=(f[i][a[i]][0]+pre[a[i]-1][0]+pre[a[i]-1][1])%mo; &#125; for(int j=1;j&lt;=200;j++)&#123; pre[j][0]=(pre[j-1][0]+f[i][j][0])%mo; pre[j][1]=(pre[j-1][1]+f[i][j][1])%mo; &#125; for(int j=200;j&gt;=1;j--)&#123; suf[j][0]=(suf[j+1][0]+f[i][j][0])%mo; suf[j][1]=(suf[j+1][1]+f[i][j][1])%mo; &#125; &#125; for(int i=1;i&lt;=200;i++) ans=(ans+f[n][i][1])%mo; write(ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP5008 【[yLOI2018] 锦鲤抄】]]></title>
    <url>%2F2019%2F12%2F19%2F%E9%A2%98%E8%A7%A3%20luoguP5008%20%E3%80%90%5ByLOI2018%5D%20%E9%94%A6%E9%B2%A4%E6%8A%84%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 首先考虑有向无环图怎么做。 有一个贪心的想法，按权值从大到小取，那么我们可以发现除了入度为$0$的一定取不到以外，总能安排一种顺序使得我们取到想要取的点。 考虑有环的情况：缩点后整张图仍然是一个有向无环图，那么对于一个有入度的强连通分量，发现也能安排一种顺序取完这个强联通分量内所有的点。对于缩完点之后的根节点代表的强联通分量，可以发现总会剩下一个点一定取不到。 那么思路就很清晰了，先缩点，然后拿个堆从大到小取点，如果一个点所在强联通分量没有入度，那么判一下这个强连通分量内是不是只剩它这个点没有取，如果是，则不能取这个点。 $Code\ Below:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define pc putchar#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=500005,M=1000005;int n,m,k,head[N],cnt,col[N],dfn[N],low[N],dep,st[N],vis[N];int top,col_cnt,sz[N],ans,in[N];struct Edge&#123; int u,v,nx;&#125;e[M&lt;&lt;1];struct node&#123; int v,id; friend bool operator &lt; (node A,node B)&#123; return A.v&lt;B.v; &#125;&#125;;priority_queue&lt;node&gt; q;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;void add(int x,int y)&#123; e[++cnt].u=x; e[cnt].v=y; e[cnt].nx=head[x]; head[x]=cnt;&#125;void tarjan(int now)&#123; dfn[now]=low[now]=++dep; st[++top]=now;vis[now]=1; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(!dfn[v])&#123; tarjan(v); low[now]=min(low[now],low[v]); &#125; else if(vis[v]) low[now]=min(low[now],dfn[v]); &#125; if(dfn[now]==low[now])&#123; int t; col_cnt++; do&#123; t=st[top--]; vis[t]=0; col[t]=col_cnt; sz[col_cnt]++; &#125;while(t!=now); &#125;&#125;signed main()&#123; n=read(),m=read(),k=read(); for(int i=1;i&lt;=n;i++) q.push((node)&#123;read(),i&#125;); for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(); add(x,y); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=cnt;i++) if(col[e[i].u]!=col[e[i].v]) in[col[e[i].v]]++; for(int i=1;i&lt;=k;i++)&#123; while(!q.empty())&#123; node now=q.top(); q.pop(); int C=col[now.id]; if(in[C])&#123;//所在强连通分量有入度 ans+=now.v; break; &#125; else&#123; if(sz[C]!=1)&#123;//所在强连通分量如果剩一个点就取不了 ans+=now.v; sz[C]--; break; &#125; &#125; &#125; &#125; write(ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>Luogu</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP5368 【[PKUSC2018]真实排名】]]></title>
    <url>%2F2019%2F12%2F15%2F%E9%A2%98%E8%A7%A3%20luoguP5368%20%E3%80%90%5BPKUSC2018%5D%E7%9C%9F%E5%AE%9E%E6%8E%92%E5%90%8D%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 签到题。 分两种情况，一种自己不翻倍，一种翻倍。 不翻倍的情况： 对于一个数，设 不翻倍大于等于它的个数$+$翻倍了还小于它的个数 这两者的和为$sum$，那么方案为$C_{sum}^k$。 翻倍的情况： 对于一个数，设有$x$个数翻倍后大于等于它（它指的是这个数翻倍后的值，下同），$y$个数大于等于它，$z$个数翻倍后还是小于它，以及这个数翻倍后增长的排名$p$。那么方案为$C{x}^{p}\times C{y+z}^{k-p-1}$。 注意还有$ai=0$要特判，方案数为$C{n}^{k}$。 $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar#define mo 998244353//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=100005;int n,k,ans[N],rk[N],l[N],jc[N],ny[N];struct node&#123; int v,id; friend bool operator &lt; (node A,node B)&#123; return A.v&lt;B.v; &#125;&#125;a[N];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res=res*x%mo; y&gt;&gt;=1; x=x*x%mo; &#125; return res;&#125;int C(int x,int y)&#123; if(x&lt;y||y&lt;0) return 0; return jc[x]*ny[y]%mo*ny[x-y]%mo;&#125;signed main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;i++) a[i].v=read(),a[i].id=i; sort(a+1,a+n+1); a[0].v=-1; for(int i=1;i&lt;=n;i++)&#123; if(a[i].v==a[i-1].v) rk[i]=rk[i-1],l[i]=l[i-1]; else rk[i]=n-i+1,l[i]=i; &#125; jc[0]=1; for(int i=1;i&lt;=n;i++) jc[i]=jc[i-1]*i%mo; ny[n]=ksm(jc[n],mo-2); for(int i=n-1;i&gt;=0;i--) ny[i]=ny[i+1]*(i+1)%mo; for(int i=1;i&lt;=n;i++)&#123; if(a[i].v==0)&#123; ans[a[i].id]=C(n,k); continue; &#125; int x=n-l[i],y=upper_bound(a+1,a+n+1,(node)&#123;(a[i].v+1)/2-1,0&#125;)-a-1,id=a[i].id,z; ans[id]=C(x+y,k); int pos=lower_bound(a+1,a+n+1,(node)&#123;a[i].v*2,0&#125;)-a,zhang=rk[i]-rk[pos]-1; x=pos-1-l[i],y=n-pos+1,z=l[i]-1; ans[id]=(ans[id]+C(x,zhang)*C(y+z,k-zhang-1)%mo)%mo; &#125; for(int i=1;i&lt;=n;i++) writeln(ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP-S 2019 退役记]]></title>
    <url>%2F2019%2F12%2F15%2FCSP%202019%20%E9%80%80%E5%BD%B9%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day -1上午模拟赛，前两题签到，T3笛卡尔树，没啥思路。不过$zyy$都写挂惹，我不会也没什么问题吧。（滑稽 中午的时候发现某篇以前写的题解被叉了，修了一个中午。随后开始打开知乎…不知不觉一下午过去了 （知乎它不香吗）。吃饭前总算订正完了。 晚上估计又在颓废？心血来潮打开2018普及T3摆渡车，这不是傻逼题吗？写了个$O(tm)$的，过了。又想复习斜率优化于是写了一遍，调了40分钟才过。这是要退役的节奏？/kk Day 0上午又是模拟赛，T1标准D2T1，结果小细节写错调了两个钟头。T2贪心，没想出来。T3神仙题，打暴力。$zyy$又没有AK？大雾。 下午两点出发去酒店咯。 晚上敲了敲板子，感觉自已挺多东西还不熟练，九点钟去窜门才发现大家居然都在颓废？？ Day 1早上出了点小意外，酒店停车场不给我们的大巴出去？？？7：40分出发，离考场5分钟车程，结果8：15左右才到。进考场的时候已经在公布压缩包密码了。 拿到题，先秒了T1。T2括号序列问题，显然是栈搞一下，一直考虑用线段树维护巴拉巴拉的东西，导致一个小时的时候才想出正解。但是，但是，考后越想越不对，牛客上交了发，好像是锅了，但是又不确定交的是不是考场代码，特别慌张，因此也影响了Day2心情。赛后发现过了.. 大众分100+100+10=210，今年D1T3神仙题。自闭。 回酒店以后就是颓废.. Day 2Day2早早来到考场，考试前一直趴着，昨天的T2越想越不对。 准时开考，扫了一眼题，感觉T1T2两道DP题？于是先打了T3的55分暴力。发现T2的64分$n^2$很简单，也写了一发。盯着DP式子看了好久，还是没想出怎么优化到$n\ log\ n$，出来听他们说，转移点越靠右越优，他们说打表打出来是对的？我记得自己在考试的时候推翻了这个结论，自闭了。 大概还剩两个钟头，开始看T1，马上就感觉是容斥一样的东西，突然又觉得很假，万一有多个列不满足条件怎么办(显然大于一半的只有一列啊我在想什么我真是傻逼)？于是觉得这是道不可做题。 最后打了暴力，特别垃圾的48分暴力。 大众分100+88+55=243，又不到大众分。 Day INF最终得分100+100+0+48+64+55=367。没挂分，但Day2实在考的太烂了。 很不理想的成绩，混个一等退役了，回归文化课学习。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP5216 【DLS 采花】]]></title>
    <url>%2F2019%2F11%2F12%2F%E9%A2%98%E8%A7%A3%20luoguP5216%20%E3%80%90DLS%20%E9%87%87%E8%8A%B1%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 显然每个数的贡献可以单独算，即这个数的值$\times$方案数。 现在的问题就是，对于一个数，有多少种排列，使得它的因子不在它之前。我们不需要知道因子的值，只需要知道个数，设为$x$。 方案特别好算，考虑算上它本身的$x+1$个数，先随便在数列中放，方案为$C_n^{x+1}$，考虑$x+1$个数中，它本身要放最前面，剩下$x$个随便放，即$x!$，考虑剩下的$n-x-1$个数随便放，方案为$(n-x-1)!$。 所以对于一个数，贡献为$a[i]\times C_n^{x+1}\times x!\times (n-x-1)!$。 预处理阶乘逆元即可。 $Code\ Below:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar#define mo 998244353//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=100005;int n,a[N],tong[N],gs[N],inv[N],jc[N],ans;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;void part(int id,int x)&#123; for(int i=1;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; gs[id]+=tong[i]; if(i*i!=x) gs[id]+=tong[x/i]; &#125; &#125; gs[id]--;&#125;int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res=res*x%mo; y&gt;&gt;=1; x=x*x%mo; &#125; return res;&#125;int C(int x,int y)&#123; return jc[x]*inv[y]%mo*inv[x-y]%mo;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),tong[a[i]]++; for(int i=1;i&lt;=n;i++) part(i,a[i]); jc[0]=1; for(int i=1;i&lt;=n;i++) jc[i]=jc[i-1]*i%mo; inv[n]=ksm(jc[n],mo-2); for(int i=n-1;i&gt;=0;i--) inv[i]=inv[i+1]*(i+1)%mo; for(int i=1;i&lt;=n;i++) ans=(ans+C(n,gs[i]+1)*jc[gs[i]]%mo*jc[n-gs[i]-1]%mo*a[i]%mo)%mo; write(ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>逆元</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 ABC138F 【Coincidence】]]></title>
    <url>%2F2019%2F11%2F04%2F%E9%A2%98%E8%A7%A3%20ABC138F%20%E3%80%90Coincidence%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 题意：求$L\leq x\leq y\leq R$且满足$y\% x=y\oplus x$的$(x,y)$的对数。$(1\leq L\leq R\leq 10^{18})$ $y\% x$显然很不好做，我们需要转化一下。 我们发现： $1.$ 当$2x\leq y$，有$y-x&gt;y\% x$； $2.$ 当$2x&gt;y$，有$y-x=y\%x$。 $3.$ $y\oplus x\geq y-x$。 于是： $2x\leq y$时，不存在$y\oplus x=y\% x$。 所以$2x&gt;y$，即$x$和$y$的位数相同，最高位同时为$1$。 那么问题就转化成，求$y-x=y\oplus x$的$(x,y)$的对数。 满足$y-x=y\oplus x$，那么$y$二进制下为$1$，$x$为$0$或$1$，$y$二进制下为$0$，$x$必为$0$。 考虑数位$dp$，这种类型的数位$dp$不像常规的数位$dp$，用$0\sim r$的答案减去$0\sim l-1$的答案。 我们考虑枚举哪一位为最高位，然后$dp[i][x1][x2]$表示前$i$位，数的大小有没有达到下界$L$，有没有达到上界$R$的方案数，转移时先枚举$y$，再枚举$x$。 还有一道类似的题，做法是相同的。 $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar#define mo 1000000007//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=65;int l,r,lenl,lenr,pl[N],pr[N],dp[N][2][2],ans;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;int dfs(int pos,int x1,int x2)&#123; if(!pos) return 1; if(dp[pos][x1][x2]!=-1) return dp[pos][x1][x2]; int &amp;res=dp[pos][x1][x2];res=0; int t1=x1?pl[pos]:0,t2=x2?pr[pos]:1; for(int y=t1;y&lt;=t2;y++) for(int x=t1;x&lt;=y;x++) res=(res+dfs(pos-1,x1&amp;(x==t1),x2&amp;(y==t2)))%mo; return res;&#125;signed main()&#123; memset(dp,-1,sizeof(dp)); l=read(),r=read(); while(l)&#123; pl[++lenl]=l&amp;1; l&gt;&gt;=1; &#125; while(r)&#123; pr[++lenr]=r&amp;1; r&gt;&gt;=1; &#125; for(int i=lenl;i&lt;=lenr;i++) ans=(ans+dfs(i-1,i==lenl,i==lenr))%mo;//枚举哪个最高位为1 write(ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF173E 【Camping Groups】]]></title>
    <url>%2F2019%2F11%2F04%2F%E9%A2%98%E8%A7%A3%20CF173E%20%E3%80%90Camping%20Groups%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 数据结构码农好题。 先总结一些限制： 1.包含$x,y$的队长的地位要$\geq max(p[x],p[y])$。 2.对于$x,y$，设$age[x]\leq age[y]$，则队长的年龄限制为$[age[y]-k,age[x]+k]$，若$age[y]-k&gt;age[x]+k$则不合法。 首先我们预处理每个人做队长时，这个队的最大人数。这东西我们设为$can[i]$，求这个东西可以按地位排个序，然后主席树即可。 然后考虑离线做这道题，根据第一个限制，我们对于所有询问，按$max(p[x],p[y])$从大到小排序。那么做这个询问前，我们需要把$p[i]\geq max(p[x],p[y])$的每个人作为队长的$can[i]$插入到线段树上这个人年龄的位置。然后在这个询问需要满足的年龄限制$($也就是限制$2)$的范围内，查询最大的$can[i]$即可。 有了思路，代码其实就是一堆数据结构拼凑起来，注意实现细节即可。 $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define pc putchar//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=100005;int n,m,k,b[N],B,pos[N],same[N],can[N],rt[N],ans[N];struct node&#123; int p,age,id; friend bool operator &lt; (node A,node B)&#123; return A.p&lt;B.p; &#125;&#125;a[N];struct que&#123; int x,y,v;&#125;q[N];struct lxy&#123; int l,r,id;&#125;;vector&lt;lxy&gt; g[N];vector&lt;int&gt; alb[N];struct ChairMan_Tree&#123; int ls[N*40],rs[N*40],sum[N*40],cnt; void build(int &amp;now,int l,int r,int x)&#123; now=++cnt; if(l==r)&#123; sum[now]++; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) build(ls[now],l,mid,x); else build(rs[now],mid+1,r,x); sum[now]=sum[ls[now]]+sum[rs[now]]; &#125; void update(int &amp;now,int pre,int l,int r,int x)&#123; now=++cnt; ls[now]=ls[pre],rs[now]=rs[pre],sum[now]=sum[pre]+1; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(ls[now],ls[pre],l,mid,x); else update(rs[now],rs[pre],mid+1,r,x); &#125; int query(int now,int l,int r,int x,int y)&#123; if(!now) return 0; if(x&lt;=l&amp;&amp;r&lt;=y) return sum[now]; int mid=(l+r)&gt;&gt;1,res=0; if(x&lt;=mid) res+=query(ls[now],l,mid,x,y); if(mid+1&lt;=y) res+=query(rs[now],mid+1,r,x,y); return res; &#125;&#125;Tr;struct Segment_Tree&#123; int ls[N*40],rs[N*40],mx[N*40],cnt,rt; void update(int l,int r,int x,int v,int &amp;k)&#123; if(!k) k=++cnt; if(l==r)&#123; mx[k]=max(mx[k],v); return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,x,v,ls[k]); else update(mid+1,r,x,v,rs[k]); mx[k]=max(mx[ls[k]],mx[rs[k]]); &#125; int query(int l,int r,int x,int y,int k)&#123; if(!k) return 0; if(x&lt;=l&amp;&amp;r&lt;=y) return mx[k]; int mid=(l+r)&gt;&gt;1,res=0; if(x&lt;=mid) res=max(res,query(l,mid,x,y,ls[k])); if(mid+1&lt;=y) res=max(res,query(mid+1,r,x,y,rs[k])); return res; &#125;&#125;T;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;signed main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;i++)&#123; a[i].p=read(); a[i].id=i; b[i]=a[i].p; &#125; for(int i=1;i&lt;=n;i++) a[i].age=read(); sort(b+1,b+n+1); B=unique(b+1,b+n+1)-b-1; for(int i=1;i&lt;=n;i++) a[i].p=lower_bound(b+1,b+B+1,a[i].p)-b; sort(a+1,a+n+1); Tr.build(rt[1],1,1e9,a[1].age); for(int i=2;i&lt;=n;i++) Tr.update(rt[i],rt[i-1],1,1e9,a[i].age); int R; for(int i=1;i&lt;=n;i++)&#123;//相同地位的我们在查的时候要找到最右边的人 R=i; while(R&lt;=n&amp;&amp;a[R].p==a[i].p) R++; R--; for(int j=i;j&lt;=R;j++) same[j]=R; i=R; &#125; for(int i=1;i&lt;=n;i++)&#123; pos[a[i].id]=i; can[i]=Tr.query(rt[same[i]],1,1e9,max(1,a[i].age-k),min((int)1e9,a[i].age+k)); alb[a[i].p].push_back(i); &#125; m=read(); for(int i=1;i&lt;=m;i++)&#123; q[i].x=read(); q[i].y=read(); q[i].x=pos[q[i].x]; q[i].y=pos[q[i].y]; q[i].v=max(a[q[i].x].p,a[q[i].y].p); if(a[q[i].x].age&gt;a[q[i].y].age) swap(q[i].x,q[i].y); g[q[i].v].push_back((lxy)&#123;a[q[i].y].age-k,a[q[i].x].age+k,i&#125;); &#125; for(int i=B;i&gt;=1;i--)&#123; for(int j=0;j&lt;alb[i].size();j++)&#123; int id=alb[i][j]; int age=a[id].age,val=can[id];//age这个点插入val的贡献 T.update(1,1e9,age,val,T.rt); &#125; for(int j=0;j&lt;g[i].size();j++)&#123; int l=g[i][j].l,r=g[i][j].r,id=g[i][j].id; if(l&lt;=r) ans[id]=T.query(1,1e9,l,r,T.rt); if(!ans[id]) ans[id]=-1; &#125; &#125; for(int i=1;i&lt;=m;i++) writeln(ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>主席树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP4359 【[CQOI2016]伪光滑数】]]></title>
    <url>%2F2019%2F10%2F28%2F%E9%A2%98%E8%A7%A3%20luoguP4359%20%E3%80%90%5BCQOI2016%5D%E4%BC%AA%E5%85%89%E6%BB%91%E6%95%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 首先我们要发现一个性质，就是最大的伪光滑数所有质因数相同。如果一个合法的伪光滑数有不相同的质因数，我们把小的质因数全部换成最大的，需要满足的式子$a_k^k\leq N$中，$k$没有变化，所以这个数仍旧合法，却比原来的数大。 观察到要求的第$K$大的$K$较小，那么我们用堆维护。每次取出最大值，如果这个数最大质因数的幂次大于$1$，那么把其中一个最大质因数换成较小的扔进堆里。由于最大质因数和分解的项数$k$不变，所以始终满足$a_k^k\leq N$。同时也很容易发现这样枚举是没有遗漏和重复的。 $Code\ Below:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;int n,k;int pr[105]=&#123;0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127&#125;;//31个struct node&#123; int val,p,mi,lim;//值,最大质数,幂次,下个数的限制 friend bool operator &lt; (node A,node B)&#123; return A.val&lt;B.val; &#125;&#125;;priority_queue&lt;node&gt; q; inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;signed main()&#123; n=read(),k=read(); for(int i=1;i&lt;=31;i++)&#123; int now=pr[i]; for(int j=1;now&lt;=n;j++,now=now*pr[i]) q.push((node)&#123;now,pr[i],j,i-1&#125;); &#125; while(k--)&#123; node now=q.top(); q.pop(); if(!k)&#123; write(now.val); return 0; &#125; if(now.mi&gt;1) for(int i=1;i&lt;=now.lim;i++) q.push((node)&#123;now.val/now.p*pr[i],now.p,now.mi-1,i&#125;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP4060 【[Code+1]可做题】]]></title>
    <url>%2F2019%2F10%2F07%2F%E9%A2%98%E8%A7%A3%20luoguP4060%20%E3%80%90%5BCode%2B1%5D%E5%8F%AF%E5%81%9A%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 显然是让未填的一段区间前缀异或和除端点外均为$0$最优。 我们来仔细考虑一下端点的问题： 对于一段连续的全部知道的区间，我们可以通过调节这个区间左边第一个空来使得这个区间的贡献最小，这个空位的权值我们可以枚举二进制下每一位算出来。$($注意特判从$1$开始的区间$)$。 计算过了这段区间，然后我们可以马上在它右端点右侧放一个值，消除这一段的贡献，使得之后的空位异或前缀和均为$0$。 感觉有一个小小的问题，就是两段全部知道的区间之间如果只有一个空位，是不是会出问题？ 仔细考虑一下，发现是不会的。每次计算一段连续的全部知道的区间，我们算出了这段区间左边第一个空的最优填法，然后再异或上消除左边一段连续的全部知道的区间应该填的值，就是这单个空的权值了。显然仍然是最优的。 $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=100005;int n,m,ans;struct node&#123; int p,v; friend bool operator &lt; (node A,node B)&#123; return A.p&lt;B.p; &#125;&#125;a[N];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123;if(x&lt;0)&#123;x=-x,pc('-');&#125;if(x&gt;9) write(x/10);pc(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void writesp(int x)&#123;write(x),pc(' ');&#125;int solve(int l,int r)&#123; int res=0,now=0; if(a[l].p==1)&#123;//左边不能放 for(int i=l;i&lt;=r;i++)&#123; now^=a[i].v; res+=now; &#125; &#125; else&#123; for(int i=30;i&gt;=0;i--)&#123; int cnt[2],tot[2]; cnt[0]=tot[0]=0; cnt[1]=tot[1]=1; for(int j=0;j&lt;=1;j++)&#123; for(int k=l;k&lt;=r;k++)&#123; tot[j]^=(a[k].v&gt;&gt;i)&amp;1; cnt[j]+=tot[j]; &#125; &#125; res+=(1&lt;&lt;i)*min(cnt[0],cnt[1]); &#125; &#125; return res;&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++)&#123; a[i].p=read(); a[i].v=read(); &#125; sort(a+1,a+m+1); int now=1; while(now&lt;=m)&#123; int last=now; while(now&lt;=m&amp;&amp;a[now].p+1==a[now+1].p) now++; ans+=solve(last,now); now++; &#125; write(ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>Luogu</tag>
        <tag>前缀和</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3533 【[POI2012]RAN-Rendezvous】]]></title>
    <url>%2F2019%2F09%2F24%2F%E9%A2%98%E8%A7%A3%20luoguP3533%20%E3%80%90%5BPOI2012%5DRAN-Rendezvous%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 感觉我写的最麻烦。 发现是基环树森林，显然先并查集一波，不在同一集内输出$(-1\ -1)$。 否则必然有解，然后发现一个点最终肯定走到环上，把环搞出来。 处理出每个点首次走到环的那个点是哪个，为$to[i]$。 然后如果两个点$to[i]$相同，那么这两个点的答案就是这两个点的$lca$。 否则肯定要先走到环上，然后肯定是其中一个点走向另一个点，算一下就好了。 由于本人菜，代码实现较为…复杂。 $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define pc putchar//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=500005;int n,q,fa[N],f[N],bz[N][20],vis[N],col[N],id[N],ans1,ans2;int col_cnt,size[N],inst[N],st[N],to[N],step[N],d[N],head[N],cnt;struct Edge&#123; int v,nx;&#125;e[N&lt;&lt;1];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&lt;0)&#123;x=-x;putchar('-');&#125; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void add(int x,int y)&#123; e[++cnt].v=y; e[cnt].nx=head[x]; head[x]=cnt;&#125;int find(int p)&#123; return f[p]==p?p:f[p]=find(f[p]);&#125;void uni(int x,int y)&#123; int tx=find(x),ty=find(y); if(tx!=ty) f[tx]=ty;&#125;void dfs(int now,int fa)&#123; d[now]=d[fa]+1; bz[now][0]=fa; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,now); &#125;&#125;void lca(int x,int y)&#123; if(d[x]&gt;d[y])&#123; for(int i=19;i&gt;=0;i--)&#123; if(d[bz[x][i]]&gt;=d[y])&#123; x=bz[x][i]; ans1+=1&lt;&lt;i; &#125; &#125; &#125; else if(d[y]&gt;d[x])&#123; for(int i=19;i&gt;=0;i--)&#123; if(d[bz[y][i]]&gt;=d[x])&#123; y=bz[y][i]; ans2+=1&lt;&lt;i; &#125; &#125; &#125; if(x==y) return; for(int i=19;i&gt;=0;i--)&#123; if(bz[x][i]!=bz[y][i])&#123; x=bz[x][i],y=bz[y][i]; ans1+=1&lt;&lt;i,ans2+=1&lt;&lt;i; &#125; &#125; ans1++,ans2++;&#125;int dis(int x,int y)&#123;//环上两点距离 return (id[x]-id[y]+size[col[x]])%size[col[x]];&#125;signed main()&#123; n=read(),q=read(); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++)&#123; fa[i]=read(); uni(fa[i],i); bz[i][0]=fa[i]; &#125; for(int i=1;i&lt;=n;i++)&#123;//求环,这个自己想怎么写怎么写 if(!vis[i])&#123; int now=i; int top=0; while(!vis[now])&#123; st[++top]=now; inst[now]=1; vis[now]=1; now=fa[now]; if(inst[now])&#123; col_cnt++; int t,idd=0; do&#123; t=st[top]; top--; inst[t]=0; col[t]=col_cnt; size[col_cnt]++; id[t]=++idd; &#125;while(t!=now); &#125; &#125; while(top)&#123; inst[st[top]]=0; top--; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(col[i]) continue; add(fa[i],i); &#125; for(int i=1;i&lt;=n;i++)//环上每个点的子树预处理 if(col[i]) dfs(i,0); for(int k=1;k&lt;=19;k++) for(int i=1;i&lt;=n;i++) bz[i][k]=bz[bz[i][k-1]][k-1]; for(int i=1;i&lt;=n;i++)&#123;//预处理每个点走到环上是哪个点,并且要走几步 if(col[i]) to[i]=i; else&#123; int now=i; for(int k=19;k&gt;=0;k--) if(bz[now][k])&#123; now=bz[now][k]; step[i]+=1&lt;&lt;k; &#125; to[i]=now; &#125; &#125; while(q--)&#123; int x=read(),y=read(); if(x==y)&#123; puts("0 0"); continue; &#125; int tx=find(x),ty=find(y); if(tx!=ty)&#123; puts("-1 -1"); continue; &#125; tx=to[x],ty=to[y]; if(tx==ty)&#123; ans1=0,ans2=0; lca(x,y); write(ans1),pc(' '),writeln(ans2); &#125; else&#123;//按规定输出答案 ans1=step[x],ans2=step[y]; int t1=max(ans1+dis(tx,ty),ans2),t2=max(ans1,ans2+dis(ty,tx)); if(t1&lt;t2)&#123; write(ans1+dis(tx,ty)),pc(' '),writeln(ans2); &#125; else if(t1&gt;t2)&#123; write(ans1),pc(' '),writeln(ans2+dis(ty,tx)); &#125; else&#123; t1=min(ans1+dis(tx,ty),ans2),t2=min(ans1,ans2+dis(ty,tx)); if(t1&lt;t2)&#123; write(ans1+dis(tx,ty)),pc(' '),writeln(ans2); &#125; else if(t1&gt;t2)&#123; write(ans1),pc(' '),writeln(ans2+dis(ty,tx)); &#125; else&#123; write(ans1+dis(tx,ty)),pc(' '),writeln(ans2); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>LCA</tag>
        <tag>基环树</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3517 【[POI2011]WYK-Plot】]]></title>
    <url>%2F2019%2F09%2F20%2F%E9%A2%98%E8%A7%A3%20luoguP3517%20%E3%80%90%5BPOI2011%5DWYK-Plot%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 显然的二分答案。 对于一个二分出的答案$mid$，我们要使分成的每一段中所有点离中心点的距离都小于等于$mid$，当然每一段的点是越多越好。 求一段点的最小圆覆盖，用随机增量法可以做到$O(len)$，不会的先去做最小圆覆盖。 所以难点就是怎么写$check$函数。 以找第一个连续的最长段为例，当然可以一个一个枚举过去找到最远的右端点，但是发现如果第一段就是$[1,n]$的段的话，这样做的复杂度就达到$O(n^2)$。 考虑优化一下，对于一个左端点，可以二分一下右端点，这样看起来复杂度更优一点，但是考虑如果每一段长度都为$1$，那么每次都要二分$log$次，总的是$O(n^2\ log\ n)$，显然也不行。 发现复杂度瓶颈在于每次二分得到的区间长是$O(n)$级的，那么可不可以对于一个左端点，快速的找到右端点的范围呢？我们考虑倍增，设左端点为$l$，我们倍增求出右端点的范围。设倍增得到最大的满足条件的区间长度为$2^k$，那么我们二分的左端点为$i+2^k-1$，右端点为$min(n,i+2^{k+1}-1)$，在这段区间内二分，显然复杂度就正确了。 这题好像很卡精度，随机增量法用不同的随机种子还会$WA$。如果只$WA$一两个点，考虑换个随机种子。 总复杂度$O(n\ log^2\ n)$，但是常数很大所以跑得巨慢。 $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define pc putchar//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=100005;int n,m,res[N][2],cnt,ci;double eps=1e-10,R;struct point&#123; double x,y;&#125;a[N],b[N],O;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&lt;0)&#123;x=-x;putchar('-');&#125; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;point Mid(point A,point B)&#123; return (point)&#123;(A.x+B.x)/2,(A.y+B.y)/2&#125;;&#125;double dist(point A,point B)&#123; return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));&#125;void getO(point A,point B,point C)&#123; double aa,bb,cc,dd,ee,ff; aa=A.x-C.x;bb=A.y-C.y; cc=B.x-C.x;dd=B.y-C.y; ee=A.x*A.x+A.y*A.y-C.x*C.x-C.y*C.y; ff=B.x*B.x+B.y*B.y-C.x*C.x-C.y*C.y; O.x=(dd*ee-bb*ff)/(2*aa*dd-2*bb*cc); O.y=(aa*ff-cc*ee)/(2*aa*dd-2*bb*cc); R=dist(O,A);// printf("%.5lf %.5lf",O.x,O.y),hh;// printf("%.5lf %.5lf %.5lf",dist(O,A),dist(O,B),dist(O,C));&#125;void work(int l,int r)&#123;//随机增量求最小圆覆盖,O(r-l+1) int tot=0; for(int i=l;i&lt;=r;i++) b[++tot]=a[i]; for(int i=1;i&lt;=tot;i++) swap(b[i],b[rand()%tot+1]); O=b[1],R=0; for(int i=1;i&lt;=tot;i++)&#123; if(dist(b[i],O)&gt;R+eps)&#123;//i不在圆内 O=b[i],R=0; for(int j=1;j&lt;i;j++)&#123; if(dist(b[j],O)&gt;R+eps)&#123;//j不在圆内 O=Mid(b[i],b[j]); R=dist(O,b[i]); for(int k=1;k&lt;j;k++) if(dist(b[k],O)&gt;R+eps) getO(b[i],b[j],b[k]); &#125; &#125; &#125; &#125;&#125;bool check(double lim)&#123; cnt=0; int ans; for(int i=1;i&lt;=n;i=ans+1)&#123; int k; for(k=1;i+(1&lt;&lt;k)-1&lt;=n;k++)&#123;//k=0显然可行,从1开始 work(i,i+(1&lt;&lt;k)-1); if(R&gt;lim+eps) break; &#125; ans=i; int l=i+(1&lt;&lt;(k-1))-1,r=min(n,i+(1&lt;&lt;k)-1); while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; work(i,mid); if(R&lt;lim+eps) l=mid+1,ans=mid; else r=mid-1; &#125; cnt++; res[cnt][0]=i,res[cnt][1]=ans; if(cnt&gt;m) return 0; &#125; return 1;&#125;signed main()&#123; srand(20031128); n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; a[i].x=read(); a[i].y=read(); &#125; work(1,n); double l=0,r=R; if(m&gt;1)&#123; ci=50; while(ci--&amp;&amp;r-l&gt;eps)&#123; double mid=(l+r)/2; if(check(mid)) r=mid; else l=mid; &#125; &#125; check(r); printf("%.8lf\n",r); writeln(cnt); for(int i=1;i&lt;=cnt;i++)&#123; work(res[i][0],res[i][1]); printf("%.8lf %.8lf\n",O.x,O.y); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>计算几何</tag>
        <tag>Luogu</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3513 【[POI2011]KON-Conspiracy】]]></title>
    <url>%2F2019%2F09%2F17%2F%E9%A2%98%E8%A7%A3%20luoguP3513%20%E3%80%90%5BPOI2011%5DKON-Conspiracy%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 题目大意就是，给出$n$个点，分成一个团和一个独立集的方案数。 刚看到题没什么思路，稍微想一想，我们可以得到一个初步的结论。 我们发现，如果我们找到了一组合法的方案，那么我们从团中移出两个点到独立集中是不可行的，因为这两个点必定有边。同理，从独立集移两个点到团中也是不可行的，因为这两个点之间必定没有边。 由此我们发现，对于一个合法的方案，所以如果有另外合法的方案，必定只能在这个方案的基础上改变一个点$($把一个点从独立集移到团中,或把一个点从团移到独立集中，或交换独立集和团中的各一个点$)$。 那么我们考虑怎么找合法的方案？ 显然的$2-SAT$问题，每个点拆两个点,表示分到团里还是团外，$i($编号是$i\times 2-1)$表示团里，$i’($编号是$i\times 2)$表示团外。 若$i,j$有边，$i’-&gt;j,j’-&gt;i$；若没边，$i-&gt;j’,j-&gt;i’$。$($箭头表示连边$)$。 然后我们利用拓扑序就能找到一组合法解。$($不清楚的话可参考$2-SAT$模板$)$ 剩下就是求之前所说的改变一个点可以到达的方案。$n^2$统计一下即可。只是一个小模拟 还有，$yy$一下发现$2$要特判。 $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define pc putchar//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;const int N=5005;int n,dfn[N&lt;&lt;1],low[N&lt;&lt;1],st[N&lt;&lt;1],top,ans;int col[N&lt;&lt;1],dep,vis[N&lt;&lt;1],p[N],col_cnt,nei[N],c1,wai[N],c2,a[N],b[N];bool f[N][N];vector&lt;int&gt; g[N&lt;&lt;1];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&lt;0)&#123;x=-x;putchar('-');&#125; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;void writeln(int x)&#123;write(x),hh;&#125;void add(int x,int y)&#123; g[x].push_back(y);&#125;void tarjan(int now)&#123; dfn[now]=low[now]=++dep; st[++top]=now; vis[now]=1; for(int i=0;i&lt;(int)g[now].size();i++)&#123; int v=g[now][i]; if(!dfn[v])&#123; tarjan(v); low[now]=min(low[now],low[v]); &#125; else if(vis[v]) low[now]=min(low[now],low[v]); &#125; if(dfn[now]==low[now])&#123; col_cnt++; int t; do&#123; t=st[top]; top--; vis[t]=0; col[t]=col_cnt; &#125;while(t!=now); &#125;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; int x=read(); while(x--)&#123; int t=read(); f[i][t]=1; &#125; for(int j=1;j&lt;=n;j++)&#123; if(i^j)&#123; if(f[i][j]) add(i*2,j*2-1); else add(i*2-1,j*2); &#125; &#125; &#125; if(n==2)&#123; write(2); return 0; &#125; for(int i=1;i&lt;=2*n;i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=n;i++)&#123; if(col[i*2-1]==col[i*2])&#123; write(0); return 0; &#125; &#125; for(int i=1;i&lt;=n;i++) p[i]=col[i*2-1]&gt;col[i*2]; //col[i]&gt;col[j]说明i拓扑序小于j,则取j //所以p[i]=0则在团内 // for(int i=1;i&lt;=n;i++) write(p[i]),pc(' '); for(int i=1;i&lt;=n;i++)&#123; if(!p[i]) nei[++c1]=i; else wai[++c2]=i; &#125; int ans=1; for(int i=1;i&lt;=c1;i++)&#123; int x=nei[i],cnt=0; for(int j=1;j&lt;=c2;j++)&#123; int y=wai[j]; if(f[x][y])&#123; if(cnt==1)&#123; a[i]=1e9;//不能动 break; &#125; cnt++; a[i]=y; &#125; &#125; &#125; for(int i=1;i&lt;=c2;i++)&#123; int x=wai[i],cnt=0; for(int j=1;j&lt;=c1;j++)&#123; int y=nei[j]; if(!f[x][y])&#123; if(cnt==1)&#123; b[i]=1e9; break; &#125; cnt++; b[i]=y; &#125; &#125; &#125; if(c1!=1)&#123; for(int i=1;i&lt;=c1;i++) if(!a[i]) ans++;//把i换出去 &#125; if(c2!=1)&#123; for(int i=1;i&lt;=c2;i++) if(!b[i]) ans++;//把i换进来 &#125; for(int i=1;i&lt;=c1;i++) for(int j=1;j&lt;=c2;j++) if((a[i]==wai[j]||!a[i])&amp;&amp;((b[j]==nei[i]||!b[j]))) ans++; write(ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>tarjan</tag>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP5505 【[JSOI2011]分特产】]]></title>
    <url>%2F2019%2F08%2F20%2F%E9%A2%98%E8%A7%A3%20luoguP5505%20%E3%80%90%5BJSOI2011%5D%E5%88%86%E7%89%B9%E4%BA%A7%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 考虑容斥，$ans=(&gt;=0$个人没分到的方案$)-(&gt;=1$个人没分到的方案$)+(&gt;=2$个人没分到的方案$)$… 考虑计算$&gt;=i$个人没分到的方案，每个特产分开算，最后乘起来。根据插板法，第$k$个特产的方案为$C(a[k]+n-i-1,n-i-1)$。然后还要乘上强制哪$i$个人没分到的方案，即$C(n,i)$。 设$&gt;=i$个人没分到的方案为$f[i]$，则$ans=\sum\limits_{i=0}^{n-1}(-1)^i\times f[i]$。 $Code\ Below:$1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar#define mo 1000000007//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;int n,m,a[1005],C[2005][2005],ans;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&lt;0)&#123;x=-x;putchar('-');&#125; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;int work(int x)&#123; x=n-x; int res=1; for(int i=1;i&lt;=m;i++) res=res*C[a[i]+x-1][x-1]%mo; return res*C[n][n-x]%mo; &#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;=m;i++) a[i]=read(); for(int i=0;i&lt;=2000;i++) C[i][0]=1; for(int i=1;i&lt;=2000;i++) for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mo; for(int i=0;i&lt;=n-1;i++)&#123;//&gt;=i个人没分到的方案 if(i&amp;1) ans=(ans-work(i)+mo)%mo; else ans=(ans+work(i))%mo; &#125; write(ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3968 【[TJOI2014]电源插排】]]></title>
    <url>%2F2019%2F08%2F19%2F%E9%A2%98%E8%A7%A3%20luoguP3968%20%E3%80%90%5BTJOI2014%5D%E7%94%B5%E6%BA%90%E6%8F%92%E6%8E%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 只能说$STL$大法吼啊！ 对于插入操作，用一个$multiset$，以$len$为第一关键字，右端点$r$为第二关键字排序，直接取出$begin()$即可，然后把分裂所得的左右两端重新加入。 对于删除操作，记录一下这个编号上一次插入进来的位置，我们再开一个以左端点$l$为关键字的$multiset$，然后$multiset$内二分找到该位置左右的两端区间然后合并，再插入$multiset$即可。 注意，我们操作了其中一个$multiset$，另一个中的元素也要更新，时刻保持两个$multiset$内元素相同。删除操作直接用$multiset$的$erase$和$find$函数。 对于输出答案，我是把询问以及操作离线下来，然后离散化用树状数组计算，实现也比较方便。 代码中$s1,node1$是上述第一个$multiset$，$s2,node2$是上述第二个$multiset$。 $Code \ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define pc putchar#define ite multiset&lt;node2&gt;::iterator//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;int n,m,q,tr[1000005],tot,b[1000005],cnt,top;struct node1&#123; int l,r,len; friend bool operator &lt; (node1 A,node1 B)&#123; return A.len&gt;B.len||(A.len==B.len&amp;&amp;A.r&gt;B.r); &#125;&#125;;struct node2&#123; int l,r,len; friend bool operator &lt; (node2 A,node2 B)&#123; return A.l&lt;B.l; &#125;&#125;;struct work&#123; int pos,v,tm;&#125;a[1000005];struct que&#123; int l,r,tm;&#125;qs[1000005];multiset&lt;node1&gt; s1;multiset&lt;node2&gt; s2;map&lt;int,int&gt; ma;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&lt;0)&#123;x=-x;putchar('-');&#125; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v)&#123; while(x&lt;=m)&#123; tr[x]+=v; x+=lowbit(x); &#125;&#125;int query(int x)&#123; int res=0; while(x)&#123; res+=tr[x]; x-=lowbit(x); &#125; return res;&#125;signed main()&#123; n=read(),q=read(); s1.insert((node1)&#123;1,n,n&#125;); s2.insert((node2)&#123;1,n,n&#125;); for(int i=1;i&lt;=q;i++)&#123; int x=read(); if(x==0)&#123; int l=read(),r=read(); b[++cnt]=l,b[++cnt]=r; qs[++tot]=(que)&#123;l,r,i&#125;; &#125; else&#123; if(ma[x])&#123; int pos=ma[x]; a[++top]=(work)&#123;pos,-1,i&#125;; ma[x]=0; ite R=s2.lower_bound((node2)&#123;pos,0,0&#125;); ite L=--R; ++R; node2 LL=*L,RR=*R; node2 nw=(node2)&#123;LL.l,RR.r,RR.r-LL.l+1&#125;; s2.erase(R); s2.erase(L); s2.insert(nw); s1.erase(s1.find((node1)&#123;LL.l,LL.r,LL.len&#125;)); s1.erase(s1.find((node1)&#123;RR.l,RR.r,RR.len&#125;)); s1.insert((node1)&#123;nw.l,nw.r,nw.len&#125;); &#125; else&#123; node1 t=*s1.begin(); s1.erase(s1.find(t)); s2.erase(s2.find((node2)&#123;t.l,t.r,t.len&#125;)); int l=t.l,r=t.r,mid=(l+r+1)/2; ma[x]=mid; b[++cnt]=mid; a[++top]=(work)&#123;mid,1,i&#125;; s1.insert((node1)&#123;l,mid-1,mid-l&#125;); s1.insert((node1)&#123;mid+1,r,r-mid&#125;); s2.insert((node2)&#123;l,mid-1,mid-l&#125;); s2.insert((node2)&#123;mid+1,r,r-mid&#125;); &#125; &#125; &#125; sort(b+1,b+cnt+1); m=unique(b+1,b+cnt+1)-b-1; int now=1; for(int i=1;i&lt;=tot;i++)&#123; while(now&lt;=top&amp;&amp;a[now].tm&lt;=qs[i].tm)&#123; a[now].pos=lower_bound(b+1,b+m+1,a[now].pos)-b; add(a[now].pos,a[now].v); now++; &#125; qs[i].l=lower_bound(b+1,b+m+1,qs[i].l)-b; qs[i].r=lower_bound(b+1,b+m+1,qs[i].r)-b; write(query(qs[i].r)-query(qs[i].l-1)),hh; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>平衡树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1203F2 【Complete the Projects (hard version)】]]></title>
    <url>%2F2019%2F08%2F18%2F%E9%A2%98%E8%A7%A3%20CF1203F2%20%E3%80%90Complete%20the%20Projects%20(hard%20version)%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 对于$b_i$为正的任务，显然贪心，按$a_i$从小到大排序，当前能力值大于等于$a_i$就选上。 剩下一堆任务，题目变成，选第$i$个任务需要$a_i$能力值，做完这个任务能力值减少$b_i$。考虑$dp$，$f[i][j]$表示做前$i$个任务，能力值为$j$，最多能做多少个任务。 枚举前面的任务，枚举能力值，满足条件则转移。 $dp$前要对任务排序，我们考虑按$a_i+b_i$排序，这样显然后面的任务不会影响前面的任务。 $Code \ Below:$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define pc putchar//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;int n,r,cnt1,cnt2,ans,f[105][60005],res;struct node&#123; int x,y;&#125;a[10005],b[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&lt;0)&#123;x=-x;putchar('-');&#125; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;inline bool cmp1(node A,node B)&#123; return A.x&lt;B.x;&#125;inline bool cmp2(node A,node B)&#123; return A.x+A.y&gt;B.x+B.y;&#125;signed main()&#123; n=read(),r=read(); for(int i=1;i&lt;=n;i++)&#123; int x=read(),y=read(); if(y&gt;=0) a[++cnt1]=(node)&#123;x,y&#125;; else b[++cnt2]=(node)&#123;x,y&#125;; &#125; sort(a+1,a+cnt1+1,cmp1); int now=r; for(int i=1;i&lt;=cnt1;i++)&#123;//先把正的都选上 if(now&gt;=a[i].x)&#123; ans++; now+=a[i].y; &#125; else break; &#125; sort(b+1,b+cnt2+1,cmp2); for(int i=1;i&lt;=cnt2;i++)&#123; if(now&gt;=b[i].x&amp;&amp;now&gt;=abs(b[i].y))&#123; f[i][now-abs(b[i].y)]=1; res=max(res,1); for(int j=i-1;j&gt;=1;j--) for(int k=max(abs(b[i].y),b[i].x);k&lt;=60000;k++) if(f[j][k])&#123; f[i][k-abs(b[i].y)]=max(f[i][k-abs(b[i].y)],f[j][k]+1); res=max(res,f[i][k-abs(b[i].y)]); &#125; &#125; &#125; write(ans+res); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3960 【列队】]]></title>
    <url>%2F2019%2F08%2F18%2F%E9%A2%98%E8%A7%A3%20luoguP3960%20%E3%80%90%E5%88%97%E9%98%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 $NOIP$题做的好心累。。 最后一列维护一个平衡树，每行维护一个动态开点的权值线段树。 我们给所有操作过的点一个权值，再用$ma$数组，表示值映射的编号，这样是为了在平衡树内有序。 考虑一行内经过一系列操作会变成什么样，首先本来是有序的，之后我们删除了一些点，再从行末尾插入了一些点，那么这一行的前半段还是有序的，后半段是无序的。 所以我们用权值线段树维护每一行删除了哪些节点，然后对于一个$(x,y)$的查询，如果这一行剩下的数的个数$t$大于等于要查询的$y$，我们就在权值线段树里找所有剩下的数中的第$y$大即可。否则，我们每行用一个$vector$来存储那些无序的数字，输出$vector$内第$y-t$个数即可。 然后考虑最后一列，操作很简单，就是删除排名为$x$的，然后把查询到的$(x,y)$插入最末尾，对于插入最末尾，我们直接给这个数赋一个当前最大的权值然后插进去即可，再更新一下映射数组$ma$。 代码中特判了一些$y==m$的情况。 个别变量含义： $leave:$ 每行剩下的数的个数 $R:$ 当前的最大权值 $v[i]:$ 第$i$行的$vector$(见上) $last:$ 上一次的答案(为了特判一些情况来减少操作) 其余均为数据结构的变量 $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")//#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//char buf[1&lt;&lt;21],*p1=buf,*p2=buf;using namespace std;int n,m,q,last,R,ma[5000005],val[1000005],sz[1000005],cnt[1000005],size,root,rt[300005];int ch[1000005][2],f[1000005],num,leave[300005],sum[10000005],ls[10000005],rs[10000005];vector&lt;int&gt; v[300005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&lt;0)&#123;x=-x;putchar('-');&#125; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;//-------------以下splay-----------------int chk(int x)&#123; return ch[f[x]][1]==x;&#125;void clear(int x)&#123; f[x]=ch[x][0]=ch[x][1]=val[x]=cnt[x]=sz[x]=0;&#125;void update(int x)&#123; if(x)&#123; sz[x]=cnt[x]; if(ch[x][0]) sz[x]+=sz[ch[x][0]]; if(ch[x][1]) sz[x]+=sz[ch[x][1]]; &#125;&#125;void rotate(int x)&#123; int fa=f[x],gfa=f[fa]; int which=chk(x); if(gfa) ch[gfa][chk(fa)]=x; f[x]=gfa; ch[fa][which]=ch[x][which^1]; f[ch[x][which^1]]=fa; ch[x][which^1]=fa; f[fa]=x; update(fa); update(x);&#125;void splay(int x)&#123; for(int fa;fa=f[x];rotate(x)) if(f[fa]) rotate(chk(x)==chk(fa)?fa:x); root=x;&#125;void insert(int x)&#123; if(!root)&#123; size++; root=size; sz[size]=1; cnt[size]=1; val[size]=x; return; &#125; int now=root,fa=0; while(1)&#123; if(val[now]==x)&#123; cnt[now]++; sz[now]++; update(now); update(fa); splay(now); return; &#125; fa=now; now=ch[now][x&gt;val[now]]; if(!now)&#123; size++; cnt[size]=sz[size]=1; f[size]=fa; val[size]=x; ch[size][0]=ch[size][1]=0; ch[fa][x&gt;val[fa]]=size; update(fa); splay(size); return; &#125; &#125;&#125;int get_pre()&#123; int now=ch[root][0]; while(ch[now][1]) now=ch[now][1]; return now;&#125;int get_nxt()&#123; int now=ch[root][1]; while(ch[now][0]) now=ch[now][0]; return now;&#125;int get_rank(int x)&#123; int now=root,res=0; while(1)&#123; if(x&lt;val[now]) now=ch[now][0]; else&#123; res+=ch[now][0]?sz[ch[now][0]]:0; if(x==val[now])&#123; splay(now); return res+1; &#125; res+=cnt[now]; now=ch[now][1]; &#125; &#125;&#125;int get_num(int x)&#123; int now=root; while(1)&#123; if(ch[now][0]&amp;&amp;x&lt;=sz[ch[now][0]]) now=ch[now][0]; else&#123; int t=(ch[now][0]?sz[ch[now][0]]:0)+cnt[now]; if(x&lt;=t) return val[now]; x-=t; now=ch[now][1]; &#125; &#125;&#125;void del(int x)&#123; get_rank(x); if(cnt[root]&gt;1)&#123; cnt[root]--; sz[root]--; return; &#125; if(!ch[root][0]&amp;&amp;!ch[root][1])&#123; clear(root); root=0; return; &#125; if(!ch[root][0])&#123; int t=root; root=ch[root][1]; clear(t); f[root]=0; return; &#125; if(!ch[root][1])&#123; int t=root; root=ch[root][0]; clear(t); f[root]=0; return; &#125; int pre=get_pre(),t=root; splay(pre); ch[root][1]=ch[t][1]; f[ch[t][1]]=root; clear(t); update(root);&#125;//-------------以上splay-----------------int query(int &amp;now,int l,int r,int k)&#123;//权值线段树查询k大 if(!now) now=++num; if(l==r) return l; int mid=(l+r)&gt;&gt;1,s=mid-l+1-sum[ls[now]]; if(s&gt;=k) return query(ls[now],l,mid,k); else return query(rs[now],mid+1,r,k-s);&#125;void update(int &amp;now,int l,int r,int x)&#123;//权值线段树删除位置x上的数 if(!now) now=++num; if(l==r)&#123; sum[now]=1; return; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(ls[now],l,mid,x); else update(rs[now],mid+1,r,x); sum[now]=sum[ls[now]]+sum[rs[now]];&#125;signed main()&#123; n=read(),m=read(),q=read(); for(int i=1;i&lt;=n;i++) insert(i),ma[i]=i*m; for(int i=1;i&lt;=n;i++) leave[i]=m-1; last=n*m,R=n; while(q--)&#123; int x=read(),y=read(); if(x==n&amp;&amp;y==m) write(last),hh; else if(y==m)&#123; int t=get_num(x);//最后一列第x个 write(ma[t]),hh; last=ma[t]; //ma值映射编号 del(t); ma[++R]=last; insert(R); &#125; else&#123; int ans; if(y&lt;=leave[x])&#123; leave[x]--; ans=query(rt[x],1,m-1,y); int id=ans; ans=last=(x-1)*m+ans; write(ans),hh; update(rt[x],1,m-1,id); &#125; else&#123; write(v[x][y-leave[x]-1]),hh; ans=last=v[x][y-leave[x]-1]; v[x].erase(v[x].begin()+y-leave[x]-1); &#125; int t=get_num(x);//最后一列第x个 v[x].push_back(ma[t]); del(t); ma[++R]=ans; insert(R); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>Luogu</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP4593 【[TJOI2018]教科书般的亵渎】]]></title>
    <url>%2F2019%2F08%2F18%2F%E9%A2%98%E8%A7%A3%20luoguP4593%20%E3%80%90%5BTJOI2018%5D%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 先算出所需亵渎个数$k$，观察就可以发现$k=m+1$，有一个小细节，如果从$n$开始有一段连续的空位，应该把它去掉，因为不会需要多余的亵渎。 我们计算每一次亵渎的贡献，第一次亵渎我们认为是在$0$位置。显然第一次的贡献是$\sum\limits_{i=1}^{n}i^k$ $-$ 空位的贡献。 之后我们考虑在一个空位上使用亵渎，设空位为$p$，那么有贡献的区间为$p+1 \sim n$。贡献为$\sum\limits_{i=1}^{n-p}i^k$。 最后我们减去空位多算的贡献即可。 考虑计算$\sum\limits_{i=1}^{n}i^k$，可利用拉格朗日插值，参考这里 $Code\ Below:$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define mo 1000000007using namespace std;int n,m,a[55],k,f[55],pre[55],suf[55],fac[55],ans;map&lt;int,int&gt; ma;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;inline int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res=res*x%mo; y&gt;&gt;=1; x=x*x%mo; &#125; return res;&#125;inline int calc(int p)&#123; if(p&lt;=k+2) return f[p]; int res=0; pre[0]=1; for(int i=1;i&lt;=k+2;i++) pre[i]=pre[i-1]*(p-i)%mo; suf[k+3]=1; for(int i=k+2;i&gt;=1;i--) suf[i]=suf[i+1]*(p-i)%mo; for(int i=1;i&lt;=k+2;i++)&#123; int x=pre[i-1]*suf[i+1]%mo; int fu=((k+2-i)&amp;1)?-1:1; int y=fac[i-1]*fac[k+2-i]*fu%mo; res=(res+f[i]*x%mo*ksm(y,mo-2)%mo)%mo; &#125; return (res+mo)%mo;&#125;signed main()&#123; fac[0]=1; for(int i=1;i&lt;=52;i++) fac[i]=fac[i-1]*i%mo; int T=read(); while(T--)&#123; n=read(),m=read(); k=m+1; ma.clear(); for(int i=1;i&lt;=m;i++) a[i]=read(),ma[a[i]]=1; sort(a+1,a+m+1); while(ma[n]) n--,k--,m--; for(int i=1;i&lt;=k+2;i++) f[i]=(f[i-1]+ksm(i,k))%mo; ans=calc(n); for(int i=1;i&lt;=m;i++) ans=(ans-ksm(a[i],k))%mo; for(int i=1;i&lt;=m;i++) ans=(ans+calc(n-a[i]))%mo; for(int i=1;i&lt;=m;i++) for(int j=i-1;j&gt;=1;j--) ans=(ans-ksm(a[i]-a[j],k))%mo; write((ans+mo)%mo),hh; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>多项式</tag>
        <tag>拉格朗日插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2857 【[USACO06FEB]稳定奶牛分配Steady Cow Assignment】]]></title>
    <url>%2F2019%2F07%2F17%2F%E9%A2%98%E8%A7%A3%20luoguP2857%20%E3%80%90%5BUSACO06FEB%5D%E7%A8%B3%E5%AE%9A%E5%A5%B6%E7%89%9B%E5%88%86%E9%85%8DSteady%20Cow%20Assignment%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 考虑$B$的范围比较小，那就$B^2$暴力枚举所有的座次区间。枚举到一个座次从$l$到$r$的区间，意义是奶牛只能选它心目中座次从$l$到$r$区间的牛棚。 然后就是判断区间是否可行，考虑网络流，源点向奶牛连边，奶牛向可选牛棚连边，牛棚向汇点连它容量的边。$Dinic$判断最大流是否是$n$。 不用当前弧优化好像会$T$？ $Code\ Below:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,b,g[1005][25],ans=1e9,st,ed,tot,can[25],head[1025],cnt,d[1025],cur[1025];struct Edge&#123; int v,nx,s;&#125;e[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void write(int x)&#123; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;inline void add(int x,int y,int s)&#123; e[++cnt].v=y; e[cnt].s=s; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline bool bfs()&#123; for(int i=st;i&lt;=ed;i++) cur[i]=head[i],d[i]=0; d[st]=1; queue&lt;int&gt; q; q.push(st); while(!q.empty())&#123; int now=q.front(); q.pop(); for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(!d[v]&amp;&amp;e[i].s)&#123; d[v]=d[now]+1; q.push(v); &#125; &#125; &#125; return d[ed];&#125;int dfs(int now,int ma)&#123; if(now==ed)&#123; tot+=ma; return ma; &#125; int used=0,t; for(int i=cur[now];i;i=e[i].nx)&#123; cur[now]=i; int v=e[i].v; if(d[v]==d[now]+1&amp;&amp;e[i].s)&#123; if(t=dfs(v,min(e[i].s,ma-used)))&#123; e[i].s-=t; e[i^1].s+=t; used+=t; if(used==ma) break; &#125; &#125; &#125; return used;&#125;void build(int l,int r)&#123; cnt=1; memset(head,0,sizeof(head)); for(int i=1;i&lt;=n;i++) add(st,i,1),add(i,st,0); for(int i=1;i&lt;=n;i++) for(int j=l;j&lt;=r;j++) add(i,n+g[i][j],1),add(n+g[i][j],i,0); for(int i=1;i&lt;=b;i++) add(n+i,ed,can[i]),add(ed,n+i,0);&#125;signed main()&#123; n=read(),b=read(); st=0,ed=n+b+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=b;j++) g[i][j]=read(); for(int i=1;i&lt;=b;i++) can[i]=read(); for(int i=1;i&lt;=b;i++) for(int j=i;j&lt;=b;j++)&#123; if(j-i+1&gt;=ans) continue; build(i,j); tot=0; while(bfs()) dfs(st,1e9); if(tot==n) ans=j-i+1; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3025 【[USACO11OPEN]忘记密码Forgotten Password】]]></title>
    <url>%2F2019%2F06%2F26%2F%E9%A2%98%E8%A7%A3%20luoguP3025%20%E3%80%90%5BUSACO11OPEN%5D%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81Forgotten%20Password%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 或许你们更愿意看短一点的代码。 每个密码单词长度小于等于$20$，那么我们在$dp$时直接暴力判断能不能匹配。 $ans[i]$表示长度为$i$时候的答案，为$””$时表示不存在。对于原密码的每一位，枚举所有单词，钦定这个单词的结尾为这一位，然后找到开头，看一下中间一段能不能匹配。如果能匹配，看一下答案是否更优。判断字典序以及字符串拼接利用强大的$string$即可。 代码很短很好懂： 复杂度$O(L\times NW\times 20)$。12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int len,n;char p[1005];string s[1005],ans[1005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline bool check(int st,int id)&#123; for(int i=0;i&lt;s[id].size();i++) if(p[st+i]!='?'&amp;&amp;p[st+i]!=s[id][i]) return 0; return 1;&#125;signed main()&#123; len=read(),n=read(); scanf("%s",p+1); for(int i=1;i&lt;=n;i++) cin&gt;&gt;s[i]; for(int i=1;i&lt;=len;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(s[j].size()&gt;i) continue; int st=i-s[j].size(); if(st&gt;0&amp;&amp;ans[st]=="") continue; if(check(st+1,j)) if(ans[i]==""||ans[i]&gt;ans[st]+s[j]) ans[i]=ans[st]+s[j]; &#125; &#125; cout&lt;&lt;ans[len]; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3031 【[USACO11NOV]高于中位数Above the Median】]]></title>
    <url>%2F2019%2F06%2F24%2F%E9%A2%98%E8%A7%A3%20luoguP3031%20%E3%80%90%5BUSACO11NOV%5D%E9%AB%98%E4%BA%8E%E4%B8%AD%E4%BD%8D%E6%95%B0Above%20the%20Median%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 对于这种中位数的题目，按照套路，把大于等于$x$的置为$1$，小于$x$的置为$-1$，然后先计算一波前缀和。 然后，问题就转化成要找满足$sum[r]-sum[l-1]&gt;=0$的$(l,r)$的对数。 枚举这个$l-1$，即枚举$0$到$n-1$，每次求$sum[r]&gt;=sum[l-1]$的$r$的个数，显然我们可以用树状数组很方便的维护出来，那么这题就解决了。 注意$sum$可能为负，下标要进行整体加。 复杂度$O(n\ log \ n)$。 $Code\ below:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,m,a[100005],b[100005],s[100005],tr[500005],tong[500005];ll ans;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline int lowbit(int x)&#123; return (x)&amp;(-x);&#125;inline int change(int x)&#123; return x+100001;&#125;inline void add(int x,int v)&#123; while(x&lt;=210000)&#123; tr[x]+=v; x+=lowbit(x); &#125;&#125;inline int query(int x)&#123; int res=0; while(x)&#123; res+=tr[x]; x-=lowbit(x); &#125; return res;&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); if(a[i]&gt;=m) b[i]=1; else b[i]=-1; &#125; add(change(0),1); tong[change(0)]++; for(int i=1;i&lt;=n;i++)&#123; s[i]=s[i-1]+b[i]; add(change(s[i]),1); tong[change(s[i])]++; &#125; for(int i=0;i&lt;n;i++)&#123; int t=n-i-query(change(s[i]))+tong[change(s[i])]; ans+=t; add(change(s[i]),-1); tong[change(s[i])]--; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>树状数组</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3963 【[TJOI2013]奖学金】]]></title>
    <url>%2F2019%2F06%2F18%2F%E9%A2%98%E8%A7%A3%20luoguP3963%20%E3%80%90%5BTJOI2013%5D%E5%A5%96%E5%AD%A6%E9%87%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 先成绩从大到小排序，然后考虑枚举哪一同学的成绩为中位数。 $f[i]$表示第$i$个同学的成绩作为中位数时，左边$n/2$个最小值的和 $g[i]$表示…同理，为右边$n/2$个最小值的和 $f[i],g[i]$满足$n/2+1&lt;=i&lt;=c-n/2($左右都必须有$n/2$个数$)$ 然后从大到小枚举答案，注意$f[i],g[i]$是不包括第$i$个的，所以若$f[i]+g[i]+money[i]&lt;=F$，输出答案。 $Code\ below:$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,c,tot,f[200005],g[200005];struct node&#123; int sc,mn;&#125;a[200005];priority_queue&lt;int&gt; q;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline bool cmp(node A,node B)&#123; return A.sc&lt;B.sc;&#125;signed main()&#123; n=read(),c=read(),tot=read(); for(int i=1;i&lt;=c;i++)&#123; a[i].sc=read(); a[i].mn=read(); &#125; sort(a+1,a+c+1,cmp); int sum=0; for(int i=1;i&lt;=n/2;i++)&#123; q.push(a[i].mn); sum+=a[i].mn; &#125; for(int i=n/2+1;i&lt;=c-n/2;i++)&#123; f[i]=sum; if(a[i].mn&lt;q.top())&#123; sum-=q.top(); sum+=a[i].mn; q.pop(); q.push(a[i].mn); &#125; &#125; while(!q.empty()) q.pop(); sum=0; for(int i=c;i&gt;=c-n/2+1;i--)&#123; q.push(a[i].mn); sum+=a[i].mn; &#125; for(int i=c-n/2;i&gt;=n/2+1;i--)&#123; g[i]=sum; if(a[i].mn&lt;q.top())&#123; sum-=q.top(); sum+=a[i].mn; q.pop(); q.push(a[i].mn); &#125; &#125; for(int i=c-n/2;i&gt;=n/2+1;i--)&#123; if(f[i]+g[i]+a[i].mn&lt;=tot)&#123; printf("%d",a[i].sc); return 0; &#125; &#125; printf("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>Luogu</tag>
        <tag>堆</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP4166 【[SCOI2007]最大土地面积】]]></title>
    <url>%2F2019%2F06%2F12%2F%E9%A2%98%E8%A7%A3%20luoguP4166%20%E3%80%90%5BSCOI2007%5D%E6%9C%80%E5%A4%A7%E5%9C%9F%E5%9C%B0%E9%9D%A2%E7%A7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 这里补充一下三分的做法。 首先$n^2$枚举对角线，然后我们要算的是在对角线左边最大的三角形和对角线右边最大的三角形。 显然如果我们任选一侧，从对角线的一个顶点到另一个顶点依次计算，三角形的面积肯定是先增大后减小的，所以考虑三分。 显然我们三分凸包上点的下标，然而我们会遇到一个问题：比如我们的顶点标号是$0-6$，当前我们枚举到对角线$1-4$，然后我们在对角线左边三分的话，我们发现这些点的下标变成了$5,6,0$，三分起来很麻烦。 这里我用的小技巧，就是把点再复制一份，即总共有$cnt$个点，我们分成$0- (cnt-1)$，$cnt-(2\times cnt-1)$相同的两份，枚举对角线时，我们在第二份中枚举，比如枚举到$(i,j)$，那么三分时，左右区间分别是$(j-cnt+1,i-1)$，$(i+1,j-1)$，实现起来就比较方便。 注意三分时，因为我们三分参数是下标，所以当$r-l=2$时特判一下，否则会死循环。 总复杂度$O(n^2 log\ n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,st[10005],top,cnt;double eps=1e-8,ans;struct point&#123; double x,y;&#125;a[10005],t[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline bool cmp(point A,point B)&#123; return fabs(A.x-B.x)&lt;eps?A.y&lt;B.y:A.x&lt;B.x;&#125;inline double cross(point A,point B)&#123; return A.x*B.y-A.y*B.x;&#125;point operator - (point A,point B)&#123; return (point)&#123;A.x-B.x,A.y-B.y&#125;;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); sort(a+1,a+n+1,cmp); top=0; for(int i=1;i&lt;=n;i++)&#123; st[++top]=i; while(top&gt;=3&amp;&amp;cross(a[st[top]]-a[st[top-2]],a[st[top-1]]-a[st[top-2]])&gt;=0)&#123; st[top-1]=st[top]; top--; &#125; &#125; for(int i=1;i&lt;=top;i++) t[++cnt]=a[st[i]]; top=0; for(int i=1;i&lt;=n;i++)&#123; st[++top]=i; while(top&gt;=3&amp;&amp;cross(a[st[top]]-a[st[top-2]],a[st[top-1]]-a[st[top-2]])&lt;=0)&#123; st[top-1]=st[top]; top--; &#125; &#125; for(int i=top-1;i&gt;=2;i--) t[++cnt]=a[st[i]]; t[0]=t[cnt]; for(int i=cnt+1;i&lt;2*cnt;i++) t[i]=t[i-cnt]; for(int i=cnt;i&lt;2*cnt;i++)&#123; for(int j=i+2;j&lt;2*cnt;j++)&#123; int l,r,lmid,rmid,left,right; l=i+1,r=j-1; point D=t[j]-t[i]; while(r-l&gt;1)&#123; if(r-l==2)&#123; if(cross(t[l]-t[i],D)&gt;cross(t[r]-t[i],D)) r--; else l++; break; &#125; lmid=l+(r-l)/3; rmid=r-(r-l)/3; if(cross(t[lmid]-t[i],D)&gt;cross(t[rmid]-t[i],D)) r=rmid; else l=lmid; &#125; if(r-l==1)&#123; if(cross(t[r]-t[i],D)&gt;cross(t[l]-t[i],D)) right=r; else right=l; &#125; else right=l; r=i-1,l=j-cnt+1; while(r-l&gt;1)&#123; if(r-l==2)&#123; if(cross(D,t[l]-t[i])&gt;cross(D,t[r]-t[i])) r--; else l++; break; &#125; lmid=l+(r-l)/3; rmid=r-(r-l)/3; if(cross(D,t[lmid]-t[i])&gt;cross(D,t[rmid]-t[i])) r=rmid; else l=lmid; &#125; if(r-l==1)&#123; if(cross(D,t[r]-t[i])&gt;cross(D,t[l]-t[i])) left=r; else left=l; &#125; else left=l; ans=max(ans,(cross(t[right]-t[i],D)+cross(D,t[left]-t[i]))/2.); &#125; &#125; printf("%.3lf",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>Luogu</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF933C 【A Colourful Prospect】]]></title>
    <url>%2F2019%2F06%2F10%2F%E9%A2%98%E8%A7%A3%20CF933C%20%E3%80%90A%20Colourful%20Prospect%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 调了一下午才调出来。主要是这道题的数据太能构造了，导致每次改完都只能多过几个点。 对于这种问平面被图形分割成几个部分的题，如果你对欧拉公式熟悉的话，发现直接套用就好： V-E+R=2其中，$V$是交点个数，$E$是边数，$R$是被分割的平面数。 由于这道题几个分割的圆可以不连通，改一下公式即可： V-E+R=C+1其中$C$是平面上圆所构成的联通块个数。 发现答案就是求$R$，所以我们考虑求出$V,E,C$： 首先是求$V$，也是最麻烦的一个，其实就是圆与圆求交点，然后进行去重。$dalao$请略过。我是直接利用两个圆的解析方程相减，求出经过交点的直线，然后再直线与圆求交。应该有更简单的方法，我太菜了。 具体在草稿纸上手算一下即可，然后存下所有的点排序去重。 $WA$了十多次，最后发现主要是求直线与圆的交点，解一元二次方程算$delta$的时候，如果两圆刚好相切，算出来总是$-0.0000000\dots$导致错误。所以用$eps$判一下 求$E$，直接统计每个圆上的交点个数，累加即可。 求$C$，对于有交的两个圆，用并查集并起来，最后就是联通块个数。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,R,V,E,C,tot,f[105],s[105],vis[105];double eps=1e-5,r[105];struct point&#123; double x,y; int id1,id2;&#125;a[105],jiao[105];//R+V-E=C+1inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;point operator + (point A,point B)&#123; return (point)&#123;A.x-B.x,A.y+B.y&#125;;&#125;point operator - (point A,point B)&#123; return (point)&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline int dis(point A,point B)&#123; return (A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y);&#125;inline int find(int p)&#123; return f[p]==p?p:f[p]=find(f[p]);&#125;inline bool cmp(point A,point B)&#123; return fabs(A.x-B.x)&lt;eps?A.y&lt;B.y:A.x&lt;B.x;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; a[i].x=read(); a[i].y=read(); r[i]=read(); f[i]=i; &#125; C=n; for(int i=1;i&lt;=n;i++)&#123;//这么长全是在求圆的交点 for(int j=i+1;j&lt;=n;j++)&#123; int ds=r[i]+r[j]; if(ds*ds&lt;dis(a[i],a[j])) continue;//两圆相离 int tx=find(i),ty=find(j); if(dis(a[i],a[j])&lt;fabs(r[i]-r[j])*fabs(r[i]-r[j])) continue; if(tx!=ty) f[tx]=ty,C--; double a1=a[i].x,b1=a[i].y,a2=a[j].x,b2=a[j].y,r1=r[i],r2=r[j]; double k,b; if(fabs(b1-b2)&lt;eps)&#123; double x=(a2*a2-a1*a1+r1*r1-r2*r2)/(2*a2-2*a1); jiao[++tot].x=x; jiao[tot].y=b1+sqrt(r1*r1-(x-a1)*(x-a1)); jiao[tot].id1=i; jiao[tot].id2=j; jiao[++tot].x=x; jiao[tot].y=b1-sqrt(r1*r1-(x-a1)*(x-a1)); jiao[tot].id1=i; jiao[tot].id2=j; if(fabs(sqrt(r1*r1-(x-a1)*(x-a1)))&lt;eps) tot--; continue; &#125; else k=(2*a1-2*a2)/(2*b2-2*b1),b=(r1*r1-r2*r2+a2*a2+b2*b2-a1*a1-b1*b1)/(2*b2-2*b1); // printf("k=%.2lf\n",k); double A=(k*k+1),B=(2*b*k-2*a1-2*k*b1),C=(a1*a1+b*b-2*b*b1+b1*b1-r1*r1); double delta=B*B-4*A*C; if(fabs(delta)&lt;eps) delta=0; jiao[++tot].x=((-B)-sqrt(delta))/(2*A); jiao[tot].y=jiao[tot].x*k+b; jiao[tot].id1=i; jiao[tot].id2=j; jiao[++tot].x=((-B)+sqrt(delta))/(2*A); jiao[tot].y=jiao[tot].x*k+b; jiao[tot].id1=i; jiao[tot].id2=j; if(fabs(delta)&lt;eps) tot--; &#125; &#125; sort(jiao+1,jiao+tot+1,cmp); jiao[tot+1].x=-666,jiao[tot+1].y=-666; for(int i=1;i&lt;=tot;i++)&#123; // printf("%.2lf %.2lf id1=%d id2=%d\n",jiao[i].x,jiao[i].y,jiao[i].id1,jiao[i].id2); vis[jiao[i].id1]=vis[jiao[i].id2]=1; if(fabs(jiao[i].x-jiao[i+1].x)&gt;eps||fabs(jiao[i].y-jiao[i+1].y)&gt;eps)&#123; for(int j=1;j&lt;=n;j++) if(vis[j]) s[j]++; V++; memset(vis,0,sizeof(vis)); continue; &#125; &#125; for(int i=1;i&lt;=n;i++) E+=s[i]; // printf("%d\n",E); printf("%d",E+C-V+1); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 UVA109 【SCUD Busters】]]></title>
    <url>%2F2019%2F06%2F09%2F%E9%A2%98%E8%A7%A3%20UVA109%20%E3%80%90SCUD%20Busters%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 题目大意： 给你一堆城市，每个城市由一堆点构成，城市的围墙是包含这个城市所有点的最小多边形，城市之间两两不相交。然后有给出一堆导弹的坐标，若一个导弹打在某个城市内部即可摧毁这个城市，问导弹摧毁的城市的总面积。 整道题显然就是考了对计算几何模板的掌握，显然先求出每个城市的凸包，然后判断导弹是否在凸包内。 对于判断一个点是否在凸包内，可以$O(log \ n)$求$(n$是凸包上点的个数$)$。 我们在求凸包时把点按逆时针顺序存起来，然后对于一个点，我们可以根据斜率二分出它在凸包的哪两个向量之间，那么问题就变成了点是否在三角形内。利用叉积解决即可。见代码中的$work$函数。 注意一个城市只能被摧毁一次。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,tot,sz[25],st[1005],top,vis[25];double S[25],ans;struct point&#123; int x,y;&#125;a[25][105],t[105],low[25];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline bool cmp(point A,point B)&#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x;&#125;point operator + (point A,point B)&#123; return (point)&#123;A.x+B.x,A.y+B.y&#125;;&#125;point operator - (point A,point B)&#123; return (point)&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline int cross(point A,point B)&#123; return A.x*B.y-A.y*B.x;&#125;inline void Graham(int id)&#123;//求凸包 sort(a[id]+1,a[id]+sz[id]+1,cmp); int cnt=0; top=0; for(int i=1;i&lt;=sz[id];i++)&#123; st[++top]=i; while(top&gt;=3&amp;&amp;cross(a[id][st[top]]-a[id][st[top-2]],a[id][st[top-1]]-a[id][st[top-2]])&gt;=0)&#123; st[top-1]=st[top]; top--; &#125; &#125; for(int i=1;i&lt;=top;i++) t[++cnt]=a[id][st[i]]; top=0; for(int i=1;i&lt;=sz[id];i++)&#123; st[++top]=i; while(top&gt;=3&amp;&amp;cross(a[id][st[top]]-a[id][st[top-2]],a[id][st[top-1]]-a[id][st[top-2]])&lt;=0)&#123; st[top-1]=st[top]; top--; &#125; &#125; for(int i=top-1;i&gt;=2;i--) t[++cnt]=a[id][st[i]]; sz[id]=cnt; for(int i=1;i&lt;=cnt;i++) a[id][i]=t[i]; low[id]=a[id][1]; for(int i=1;i&lt;=cnt;i++) a[id][i]=a[id][i]-low[id]; if(sz[id]&lt;=2) return; for(int i=1;i&lt;cnt;i++) S[id]+=abs(cross(a[id][i],a[id][i+1]));//计算凸包面积 S[id]+=cross(a[id][cnt],a[id][1]); S[id]/=2.;&#125;inline int len(point A)&#123; return A.x*A.x+A.y*A.y;&#125;inline bool comp(point A,point B)&#123; return cross(A,B)&gt;0||(cross(A,B)==0&amp;&amp;len(A)&lt;len(B));&#125;inline bool check(point A,point B,point C)&#123; if(abs(cross(A,C))+abs(cross(C,B))+abs(cross(A-C,B-C))==abs(cross(A,B))) return 1; return 0;&#125;inline bool work(point A,int id)&#123;//判断点A是否在第id个凸包内 if(cross(a[id][sz[id]],A)&gt;0) return 0; int pos=lower_bound(a[id]+1,a[id]+sz[id]+1,A,comp)-a[id]; return check(a[id][pos-1],a[id][pos],A);&#125;signed main()&#123; while(n=read(),n!=-1)&#123; tot++; sz[tot]=n; for(int i=1;i&lt;=sz[tot];i++)&#123; a[tot][i].x=read(); a[tot][i].y=read(); &#125; &#125; for(int i=1;i&lt;=tot;i++) Graham(i); point Q; while(scanf("%d%d",&amp;Q.x,&amp;Q.y)!=EOF)&#123; for(int i=1;i&lt;=tot;i++)&#123; if(vis[i]) continue; if(work(Q-low[i],i))&#123; vis[i]=1; ans+=S[i]; break; &#125; &#125; &#125; printf("%.2lf\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>计算几何</tag>
        <tag>UVA</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 bzoj2564 【集合的面积】]]></title>
    <url>%2F2019%2F06%2F06%2F%E9%A2%98%E8%A7%A3%20bzoj2564%20%E3%80%90%E9%9B%86%E5%90%88%E7%9A%84%E9%9D%A2%E7%A7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 题面的定义显然就是求一个点集$A,B$的闵可夫斯基和的凸包的面积的两倍。 那么这道题就是闵可夫斯基和的模板了。 所谓闵可夫斯基和，即给你两个点集$A,B$，求一个点集$C={x+y \ | \ x \in A, y \in B}$，$C$即点集$A,B$的闵可夫斯基和。 对于求闵可夫斯基和，我的理解是：我们考虑先求$A,B$的凸包，闵可夫斯基和的凸包肯定是由$A,B$凸包上的点加起来的，我们对于$A,B$的两个凸包，存的时候按点坐标从最左下角然后逆时针方向存。 因为$A,B$两个凸包的点是按逆时针存的，所以我们通过瞪眼法可以发现，如果把闵可夫斯基和的凸包上的点用一个$n\times m$的矩阵表示$(n,m$是凸包$A,B$上点的个数$)$，$(i,j$表示凸包$A$上的第$i$个点加上凸包$B$上的第$j$个点$)$那么闵可夫斯基和的凸包上的点是从左下角$(1,1)$到右上角$(n,m)$的一条路径$($需要意会$)$。然后我们两个指针分别指向$A,B$的两个凸包，每次取出两个点比较，利用叉积看谁往外偏的多就选谁。 觉得还是代码好理解，反正我是直接看代码看懂的： 1234567891011121314151617181920void minkowski()&#123; for(int i=1;i&lt;cnt1;i++) va[i]=tu[0][i+1]-tu[0][i];va[cnt1]=tu[0][1]-tu[0][cnt1]; for(int i=1;i&lt;cnt2;i++) vb[i]=tu[1][i+1]-tu[1][i];vb[cnt2]=tu[1][1]-tu[1][cnt2]; int i1=1,i2=1; tot=0; ans[++tot]=tu[0][1]+tu[1][1]; while(i1&lt;=cnt1&amp;&amp;i2&lt;=cnt2)&#123; if(cross(va[i1],vb[i2])&gt;=0) ans[tot+1]=ans[tot]+va[i1++]; else ans[tot+1]=ans[tot]+vb[i2++]; tot++; &#125; while(i1&lt;=cnt1)&#123; ans[tot+1]=ans[tot]+va[i1++]; tot++; &#125; while(i2&lt;=cnt2)&#123; ans[tot+1]=ans[tot]+vb[i2++]; tot++; &#125;&#125; $tu[0/1]$是$A,B$的两个凸包上的点，用$va,vb$存凸包上点变化的向量，那么后面通过向量加法就可以表示凸包上点的变化。 剩下就是凸包，叉积等板子，最后求面积的话其实不用再求一遍闵可夫斯基和的凸包$($我无聊又求了一遍$)$，如果求的话作用就是去掉凸包上三点共线的点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,m,st[100005],top,cnt1,cnt2,cnt,tot;ll res;double eps=1e-8;struct point&#123; ll x,y;&#125;a[100005],b[100005],tu[2][100005],va[100005],vb[100005],ans[200005],ed[200005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;point operator + (point A,point B)&#123; return (point)&#123;A.x+B.x,A.y+B.y&#125;;&#125;point operator - (point A,point B)&#123; return (point)&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline bool cmp(point A,point B)&#123; return A.x==B.x?A.y&lt;B.y:A.x&lt;B.x;&#125;inline double getk(point A,point B)&#123; if(fabs(double(A.x-B.x))&lt;eps) return 1e20; return (double)(B.y-A.y)/(double)(B.x-A.x);&#125;inline ll cross(point A,point B)&#123; return (ll)A.x*B.y-(ll)A.y*B.x;&#125;void Graham(point t[],int id,int all)&#123; cnt=top=0; for(int i=1;i&lt;=all;i++)&#123; st[++top]=i; while(top&gt;=3&amp;&amp;getk(t[i],t[st[top-2]])&lt;=getk(t[st[top-1]],t[st[top-2]]))&#123; st[top-1]=st[top]; top--; &#125; &#125; for(int i=1;i&lt;=top;i++) tu[id][++cnt]=t[st[i]]; top=0; for(int i=1;i&lt;=all;i++)&#123; st[++top]=i; while(top&gt;=3&amp;&amp;getk(t[i],t[st[top-2]])&gt;=getk(t[st[top-1]],t[st[top-2]]))&#123; st[top-1]=st[top]; top--; &#125; &#125; for(int i=top-1;i&gt;=2;i--) tu[id][++cnt]=t[st[i]];&#125;void minkowski()&#123; for(int i=1;i&lt;cnt1;i++) va[i]=tu[0][i+1]-tu[0][i];va[cnt1]=tu[0][1]-tu[0][cnt1]; for(int i=1;i&lt;cnt2;i++) vb[i]=tu[1][i+1]-tu[1][i];vb[cnt2]=tu[1][1]-tu[1][cnt2]; int i1=1,i2=1; tot=0; ans[++tot]=tu[0][1]+tu[1][1]; while(i1&lt;=cnt1&amp;&amp;i2&lt;=cnt2)&#123; if(cross(va[i1],vb[i2])&gt;=0) ans[tot+1]=ans[tot]+va[i1++]; else ans[tot+1]=ans[tot]+vb[i2++]; tot++; &#125; while(i1&lt;=cnt1)&#123; ans[tot+1]=ans[tot]+va[i1++]; tot++; &#125; while(i2&lt;=cnt2)&#123; ans[tot+1]=ans[tot]+vb[i2++]; tot++; &#125;&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) a[i].x=read(),a[i].y=read(); for(int i=1;i&lt;=m;i++) b[i].x=read(),b[i].y=read(); sort(a+1,a+n+1,cmp); sort(b+1,b+m+1,cmp); Graham(a,0,n); cnt1=cnt; Graham(b,1,m); cnt2=cnt; minkowski(); tot--; sort(ans+1,ans+tot+1,cmp); top=cnt=0; for(int i=1;i&lt;=tot;i++)&#123; st[++top]=i; while(top&gt;=3&amp;&amp;getk(ans[i],ans[st[top-2]])&lt;=getk(ans[st[top-1]],ans[st[top-2]]))&#123; st[top-1]=st[top]; top--; &#125; &#125; for(int i=1;i&lt;=top;i++) ed[++cnt]=ans[st[i]]; top=0; for(int i=1;i&lt;=tot;i++)&#123; st[++top]=i; while(top&gt;=3&amp;&amp;getk(ans[i],ans[st[top-2]])&gt;=getk(ans[st[top-1]],ans[st[top-2]]))&#123; st[top-1]=st[top]; top--; &#125; &#125; for(int i=top-1;i&gt;=2;i--) ed[++cnt]=ans[st[i]]; for(int i=1;i&lt;cnt;i++) res+=cross(ed[i],ed[i+1]); res+=cross(ed[cnt],ed[1]); printf("%lld",res); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>bzoj</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>闵可夫斯基和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2928 【[USACO09HOL]牛的打手Cattle Bruisers】]]></title>
    <url>%2F2019%2F06%2F05%2F%E9%A2%98%E8%A7%A3%20luoguP2928%20%E3%80%90%5BUSACO09HOL%5D%E7%89%9B%E7%9A%84%E6%89%93%E6%89%8BCattle%20Bruisers%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 没有题解，来补一篇。 观察到题目中$Bessie$和杀手都在动，所以考虑相对运动，以$Bessie$的位置作为原点，$Bessie$不动，只考虑杀手运动。让$Bessie$不动，直接杀手的位置和速度减去$Bessie$的即可。 考虑杀手攻击半径为$R$，转化一下即进入以$Bessie(0,0)$为圆心，$R$为半径的圆，就可攻击到$Bessie$。 所以我们只要求出每个杀手进入该圆与离开该圆的时间点即可。最后就可以对所以时间点进行排序，然后对整条时间线进行类似于扫描线的方法统计答案。 显然就是这样一张图： 求出直线与圆的交点即可。 设杀手起点为$(x,y)$，速度为$(vx,vy)$，设在$t$时刻恰好在交点，那么： (x+t\times vx)^2+(y+t\times vy)^2=r^2化简得到一个一元二次方程： (vx^2+vy^2)\times t^2+(2x\times vx+2y\times vy)\times t+x^2+y^2-r^2=0解出来即可。$($即程序里的$work)$ 注意判断$vx,vy$均为0的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")using namespace std;int n,r,top;double bx,by,bvx,bvy,eps=1e-8,L,R;struct node&#123; double x,y,vx,vy;&#125;a[500005];struct TM&#123; double t; int s;&#125;b[500005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void work(double A,double B,double C)&#123;//a*t*t+b*t+c=0 if(fabs(A)&lt;eps)&#123; if(C&lt;=0) L=0,R=1e9; else L=R=-1; return; &#125; double delta=B*B-4*A*C; if(delta&lt;0)&#123;//一元二次方程判根 L=R=-1; return; &#125; L=(-B-sqrt(delta))/(2*A); R=(-B+sqrt(delta))/(2*A); if(L&lt;0) L=0; if(R&lt;0) R=-1;&#125;inline bool cmp(TM a,TM b)&#123; return a.t&lt;b.t;&#125;signed main()&#123; n=read(),r=read(); bx=read(),by=read(),bvx=read(),bvy=read(); for(int i=1;i&lt;=n;i++)&#123; a[i].x=read()-bx; a[i].y=read()-by; a[i].vx=read()-bvx; a[i].vy=read()-bvy; &#125; for(int i=1;i&lt;=n;i++)&#123; double ds=a[i].x*a[i].x+a[i].y*a[i].y-r*r; work(a[i].vx*a[i].vx+a[i].vy*a[i].vy,2*a[i].x*a[i].vx+2*a[i].y*a[i].vy,ds); if(R!=-1) b[++top]=(TM)&#123;L,1&#125;,b[++top]=(TM)&#123;R,-1&#125;; &#125; sort(b+1,b+top+1,cmp); int sum=0,ans=0; for(int i=1;i&lt;=top;i++)&#123; sum+=b[i].s; ans=max(ans,sum); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>计算几何</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP4452 【[国家集训队]航班安排】]]></title>
    <url>%2F2019%2F06%2F02%2F%E9%A2%98%E8%A7%A3%20luoguP4452%20%E3%80%90%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E8%88%AA%E7%8F%AD%E5%AE%89%E6%8E%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 好像这道题并没有其他两篇题解说的那么简单吧？？？或者是我太菜了 考虑以请求为点进行建图，对每个请求进行拆点，拆点后两个点之间连价值为$c$，流量为$1$的边，代表着一个请求只能执行一次。 然后我们考虑时间限制： 对于一个请求，如果$0$时刻可以从$0$机场飞到该请求的起点机场，那么源点向该请求连价值为($-$飞行费用)，流量为$INF$的边，同理，若一个请求的结束时间，加上它的结束机场飞回$0$的时间小于等于总的时间限制，该请求向汇点连边。 但是每次执行完一个请求并未规定一定要飞回$0$机场，也可以飞去其他请求的起点机场，所以两两枚举请求，如果满足时间条件也进行连边。 最后考虑有$k$架飞机，所以再建一个源点，向原来的源点连费用为$0$，流量为$k$的边即可。 最后跑最大费用最大流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define time TTTTusing namespace std;int n,m,k,tim,t[205][205],w[205][205],head[100005];int vis[100005],dis[100005],cnt=1,cost,ans,time,st,ed;struct node&#123; int a,b,s,t,c;&#125;q[1005];struct Edge&#123; int v,nx,s,val;&#125;e[1000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int val,int s)&#123; e[++cnt].v=y; e[cnt].val=val; e[cnt].s=s; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline bool spfa()&#123; for(int i=0;i&lt;=ed;i++) dis[i]=-1e9,vis[i]=0; queue&lt;int&gt; q; dis[st]=0; q.push(st); while(!q.empty())&#123; int now=q.front(); q.pop(); vis[now]=0; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(dis[v]&lt;dis[now]+e[i].val&amp;&amp;e[i].s)&#123; dis[v]=dis[now]+e[i].val; if(!vis[v])&#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return dis[ed]!=-1e9;&#125;int dfs(int now,int ma)&#123; if(now==ed)&#123; ans+=ma; return ma; &#125; vis[now]=time; int used=0,t; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if((vis[v]!=time||v==ed)&amp;&amp;e[i].s&amp;&amp;dis[v]==dis[now]+e[i].val)&#123; if(t=dfs(v,min(ma-used,e[i].s)))&#123; e[i].s-=t; e[i^1].s+=t; cost+=t*e[i].val; used+=t; if(used==ma) break; &#125; &#125; &#125; return used;&#125;signed main()&#123; n=read(),m=read(),k=read(),tim=read(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) t[i][j]=read(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) w[i][j]=read(); st=m*2+5,ed=m*2+10; for(int i=1;i&lt;=m;i++)&#123; q[i].a=read(); q[i].b=read(); q[i].s=read(); q[i].t=read(); q[i].c=read(); &#125; for(int i=1;i&lt;=m;i++)&#123; add(i*2-1,i*2,q[i].c,1); add(i*2,i*2-1,-q[i].c,0); if(q[i].t+t[q[i].b][0]&lt;=tim)&#123; add(i*2,ed,-w[q[i].b][0],1e9); add(ed,i*2,w[q[i].b][0],0); &#125; else continue; if(t[0][q[i].a]&lt;=q[i].s)&#123; add(st+1,i*2-1,-w[0][q[i].a],1e9); add(i*2-1,st+1,w[0][q[i].a],0); &#125; for(int j=1;j&lt;=m;j++)&#123; if(q[i].t+t[q[i].b][q[j].a]&lt;=q[j].s)&#123; add(i*2,j*2-1,-w[q[i].b][q[j].a],1e9); add(j*2-1,i*2,w[q[i].b][q[j].a],0); &#125; &#125; &#125; add(st,st+1,0,k); add(st+1,st,0,0); while(spfa())&#123; do&#123; time++; dfs(st,1e9); &#125;while(vis[ed]==time); &#125; printf("%d",cost); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP377 【TAXI - Taxi】]]></title>
    <url>%2F2019%2F06%2F02%2F%E9%A2%98%E8%A7%A3%20SP377%20%E3%80%90TAXI%20-%20Taxi%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 每辆出租车只能接1人，显然是二分图匹配。 二分图左部为车，右部为人，车根据距离向能接到的人连边。 跑匈牙利即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define time TTTTusing namespace std;int n,m,s,lim,head[1005],vis[305],match[505];int cnt,time,ans;struct Edge&#123; int v,nx;&#125;e[100005];struct node&#123; int x,y;&#125;peo[10005],tx[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y)&#123; e[++cnt].v=y; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline int dis(int x,int y)&#123; return abs(peo[x].x-tx[y].x)+abs(peo[x].y-tx[y].y);&#125;bool find(int x)&#123; for(int i=head[x];i;i=e[i].nx)&#123; int v=e[i].v; if(vis[v]==time) continue; vis[v]=time; if(!match[v]||find(match[v]))&#123; match[v]=x; return 1; &#125; &#125; return 0;&#125;signed main()&#123; int T=read(); while(T--)&#123; memset(head,0,sizeof(head)); memset(vis,0,sizeof(vis)); memset(match,0,sizeof(match)); cnt=0,time=0,ans=0; n=read(),m=read(); s=read(),lim=read(); lim=s*lim; for(int i=1;i&lt;=n;i++)&#123; peo[i].x=read(); peo[i].y=read(); &#125; for(int i=1;i&lt;=m;i++)&#123; tx[i].x=read(); tx[i].y=read(); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(dis(i,j)*200&lt;=lim) add(i,j); for(int i=1;i&lt;=n;i++)&#123; time++; ans+=find(i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>spoj</tag>
        <tag>二分图</tag>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP4644 【[Usaco2005 Dec]Cleaning Shifts 清理牛棚】]]></title>
    <url>%2F2019%2F05%2F28%2F%E9%A2%98%E8%A7%A3%20luoguP4644%20%E3%80%90%5BUsaco2005%20Dec%5DCleaning%20Shifts%20%E6%B8%85%E7%90%86%E7%89%9B%E6%A3%9A%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 题解全是线段树啊？其实网络流也能过！！！！$($可能最近网络流题做太多了$)$ 复杂度显然是不对的(逃 我们以天数为点,然后第$i$天向第$i+1$天连$INF-1$ $($第$i$天需要人数$)$容量，$0$价值的边 源点向第一天，最后一天$+1$天向汇点连$INF$容量，$0$价值的边 然后对于每个工作天数从$s-t$的奶牛，我们从第$s$天向第$t+1$天连$INF$容量，$c$价值的边 这张图怎么理解呢？ 首先这张图的最大流肯定是$INF$ 中间第$i$天向第$i+1$天连$INF-1$容量的边，流量少了$1$，就需要靠奶牛来补齐 一头奶牛可以给$s-t$路径上的所有边补上$1$的流量 我们要计算的就是获得最大流$INF$所需要的最小费用 即跑一遍最小费用最大流 但写完发现我们$T$飞了$($可能拿到$40$到$60$分不等$)$。 怎么办？众所周知$USACO$很能卡$SPFA$，那我们考虑优化$SPFA$。先加个$SLF$优化，发现$90$分了。再加$LLL$优化，开$O2$，卡过！ 其实这道题和[NOI2008]志愿者招募做法是一样的。 只不过这题数据大一点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define time TTTTusing namespace std;int n,m,st,ed,head[500005],vis[500005],time,dis[500005];int cnt=1,ans,stt,edt;int cost;struct Edge&#123; int v,nx,val,s;&#125;e[2000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int val,int s)&#123; e[++cnt].v=y; e[cnt].val=val; e[cnt].s=s; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline bool spfa()&#123; for(int i=0;i&lt;=ed;i++) vis[i]=0,dis[i]=1e9; dis[st]=0; deque&lt;int&gt; q; int tot=1,sum=0; q.push_back(st); while(!q.empty())&#123; int now=q.front(); while(tot*dis[now]&gt;sum)&#123; q.pop_front(); q.push_back(now); now=q.front(); &#125; q.pop_front(); tot--; sum-=dis[now]; vis[now]=0; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(dis[v]&gt;dis[now]+e[i].val&amp;&amp;e[i].s)&#123; dis[v]=dis[now]+e[i].val; if(!vis[v])&#123; vis[v]=1; if(dis[v]&gt;q.front()) q.push_back(v); else q.push_front(v); sum+=dis[v]; tot++; &#125; &#125; &#125; &#125; return dis[ed]!=1e9;&#125;int dfs(int now,int ma)&#123; if(now==ed) return ans+=ma,ma; vis[now]=time; int used=0,t; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if((v==ed||vis[v]!=time)&amp;&amp;e[i].s&amp;&amp;dis[v]==dis[now]+e[i].val)&#123; if(t=dfs(v,min(ma-used,e[i].s)))&#123; e[i].s-=t; e[i^1].s+=t; cost+=e[i].val*t; used+=t; if(used==ma) break; &#125; &#125; &#125; return used;&#125;signed main()&#123; n=read(),stt=read(),edt=read(); st=stt-1,ed=edt+2; for(int i=stt;i&lt;=edt;i++)&#123; add(i,i+1,0,1e9-1); add(i+1,i,0,0); &#125; add(st,stt,0,1e9); add(stt,st,0,0); add(edt+1,ed,0,1e9); add(ed,edt+1,0,0); for(int i=1;i&lt;=n;i++)&#123; int s=read(),t=read(),c=read(); add(s,t+1,c,1e9); add(t+1,s,-c,0); &#125; while(spfa())&#123; do&#123; time++; dfs(st,1e9); &#125;while(vis[ed]==time); &#125; if(ans!=1e9) printf("-1"); else printf("%d",cost); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3980 【[NOI2008]志愿者招募】]]></title>
    <url>%2F2019%2F05%2F28%2F%E9%A2%98%E8%A7%A3%20luoguP3980%20%E3%80%90%5BNOI2008%5D%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 极其神仙的一道题 神仙就神仙在一个人可以对一段区间造成贡献 解题用到的主要是很神仙的建图方法$($看了题解$)$ 我们以天数为点,然后第$i$天向第$i+1$天连$INF-w[i]$ $($第$i$天需要人数$)$容量，$0$价值的边 源点向第一天，第$n+1$天向汇点连$INF$容量，$0$价值的边 然后对于每个工作天数从$s-t$的志愿者，我们从第$s$天向第$t+1$天连$INF$容量，$c$价值的边 这张图怎么理解呢？ 首先这张图的最大流肯定是$INF$ 中间第$i$天向第$i+1$天连$INF-w[i]$容量的边，流量少了$w[i]$，就需要靠志愿者来补齐 一个志愿者可以给$s-t$路径上的所有边补上$1$的流量 我们要计算的就是获得最大流$INF$所需要的最小费用 即跑一遍最小费用最大流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define time TTTTusing namespace std;int n,m,st,ed,head[20005],vis[20005],time,dis[20005],w[1005];int cnt=1,cost,ans;struct Edge&#123; int v,nx,val,s;&#125;e[2000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int val,int s)&#123; e[++cnt].v=y; e[cnt].val=val; e[cnt].s=s; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline bool spfa()&#123; for(int i=0;i&lt;=ed;i++) vis[i]=0,dis[i]=1e9; dis[st]=0; queue&lt;int&gt; q; q.push(st); while(!q.empty())&#123; int now=q.front(); q.pop(); vis[now]=0; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(dis[v]&gt;dis[now]+e[i].val&amp;&amp;e[i].s)&#123; dis[v]=dis[now]+e[i].val; if(!vis[v])&#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return dis[ed]!=1e9;&#125;int dfs(int now,int ma)&#123; if(now==ed) return ma; vis[now]=time; int used=0,t; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if((v==ed||vis[v]!=time)&amp;&amp;e[i].s&amp;&amp;dis[v]==dis[now]+e[i].val)&#123; if(t=dfs(v,min(ma-used,e[i].s)))&#123; e[i].s-=t; e[i^1].s+=t; cost+=e[i].val*t; used+=t; if(used==ma) break; &#125; &#125; &#125; return used;&#125;signed main()&#123; n=read(),m=read(); st=0,ed=n+2; for(int i=1;i&lt;=n;i++)&#123; int t=read(); add(i,i+1,0,1e9-t); add(i+1,i,0,0); &#125; add(st,1,0,1e9); add(1,st,0,0); add(n+1,ed,0,1e9); add(ed,n+1,0,0); for(int i=1;i&lt;=m;i++)&#123; int s=read(),t=read(),c=read(); add(s,t+1,c,1e9); add(t+1,s,-c,0); &#125; while(spfa())&#123; do&#123; time++; dfs(st,1e9); &#125;while(vis[ed]==time); &#125; printf("%d",cost); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3480 【[POI2009]KAM-Pebbles】]]></title>
    <url>%2F2019%2F05%2F21%2F%E9%A2%98%E8%A7%A3%20luoguP3480%20%E3%80%90%5BPOI2009%5DKAM-Pebbles%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 博弈论题题都是神仙 这题怎么考虑？我们发现石子时刻满足从左到右递增，感觉没什么思路，那么根据博弈论的套路，我们开始。。天马行空地乱想。 先考虑$SG$函数，发现这题取石子的限制是时刻在变的，显然不行。 然后，这题多堆石子且并不相互独立，没什么表打，打表也滚粗了。 石子个数递增？？是不是长得像阶梯？？(大雾 顺着这个瞎想的思路，再康一康题目，发现移走一堆石子，它两边石子与它的差值会变。 怎么变呢？设一堆石子移走$x$，显然左边与它的差值$-x$，右边与它的差值$+x$，这不就是阶梯$nim$吗？？ 什么？你不知道阶梯$nim$？那你肯定没有好好看洛咕日报。这里不详细展开了。 左边与它的差值$-x$，右边与它的差值$+x$，那么显然模型就是一个反向$($从右向左$)$的阶梯，做一遍阶梯$nim$，问题解决。 博弈论代码真的短：12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,a[1005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=ret*10+(ch^48);ch=getchar();&#125; return ret*ff;&#125; signed main()&#123; int T=read(); while(T--)&#123; n=read(); int ans=0; for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=n;i&gt;=1;i--) if((n-i+1)&amp;1) ans^=(a[i]-a[i-1]); puts(ans?"TAK":"NIE"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2322 【[HNOI2006]最短母串问题】]]></title>
    <url>%2F2019%2F05%2F06%2F%E9%A2%98%E8%A7%A3%20luoguP2322%20%E3%80%90%5BHNOI2006%5D%E6%9C%80%E7%9F%AD%E6%AF%8D%E4%B8%B2%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 看到$n&lt;=12$的数据范围，一眼状压$dp​$？随便开始敲了敲，一晚上就没了？ 看到题解还有一篇状压，感觉挺麻烦的。这里给出可能稍微方便一点的。 状压状态和方程应该很好想，$f[i][j]$表示状态$i$下，最后的字符串是$j$的最短长度，因为要输出方案，再来一个$g[i][j]$表示长度最短时的字符串。 做过几题字符串接龙状压题，应该很容易写出转移方程： f[to][k]=min(f[to][k],f[i][j]+chongdie)$to$显然就是$i\ |\ (1&lt;&lt;(k-1))$，即状态中多接了一个$k$，$chongdie$是$k$接在$j$后面时两个字符串的重叠部分的长度，注意是有顺序的，是$k$接$j$后面。最后，当$f$数组更新时，我们同时也更新$g$数组。 具体分析一下转移： 1、$k$是$j$的子串，可以用$string$的$find$函数轻松解决，$chongdie=0$。 2、$k$不是$j$的子串，我们暴力匹配，枚举$j$从哪一位开始与$k$重叠，非常暴力，可以见代码。 答案显然易见，就是$min(\sum\limits_{i=1}^{n}f[(1&lt;&lt;n)-1][i]))$，然后取出所有长度最小的$g[(1&lt;&lt;n)-1][i]$，排遍序得到最小字典序的答案。 代码里还有部分注释，挺好懂的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,f[5005][13],max_status,top;string s[105],g[5005][13],ans[105];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline int check(int x,int y)&#123; if(s[x].find(s[y])!=s[x].npos) return -1;//x包含y for(int i=0;i&lt;s[x].size();i++)&#123;//枚举j从哪一位开始与k重叠 bool fl=1; for(int j=i;j&lt;s[x].size();j++)&#123; if(s[y][j-i]!=s[x][j])&#123; fl=0; break; &#125; &#125; if(fl) return s[x].size()-i;//返回重叠部分长 &#125; return 0;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) cin&gt;&gt;s[i]; memset(f,0x3f,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=n;i++) f[1&lt;&lt;(i-1)][i]=s[i].length(),g[1&lt;&lt;(i-1)][i]=s[i]; max_status=(1&lt;&lt;n)-1; for(int i=0;i&lt;=max_status;i++)&#123; for(int j=1;j&lt;=n;j++)&#123;//以j结尾 if(i&amp;(1&lt;&lt;(j-1)))&#123; for(int k=1;k&lt;=n;k++)&#123;//后面接k if(!(i&amp;(1&lt;&lt;(k-1))))&#123; int to=i|(1&lt;&lt;(k-1)); int chong=check(j,k);//重叠部分长度 if(chong==-1)&#123;//j包含k if(f[i][j]&lt;f[to][j]||(f[i][j]==f[to][j]&amp;&amp;g[to][j]&gt;g[i][j]))&#123; f[to][j]=f[i][j]; g[to][j]=g[i][j]; &#125; &#125; else&#123; string t=""; for(int p=chong;p&lt;s[k].size();p++) t+=s[k][p];//t是j接上k后多出来的一段字符 t=g[i][j]+t; if((f[i][j]+s[k].size()-chong&lt;f[to][k])|| (f[i][j]+s[k].size()-chong==f[to][k]&amp;&amp;g[to][k]&gt;t))&#123; f[to][k]=f[i][j]+s[k].size()-chong; g[to][k]=t; &#125; &#125; &#125; &#125; &#125; &#125; &#125; int minn=1e9; for(int i=1;i&lt;=n;i++)&#123; if(f[max_status][i]&lt;minn)&#123; minn=f[max_status][i]; top=1; ans[top]=g[max_status][i]; &#125; else if(f[max_status][i]==minn) ans[++top]=g[max_status][i]; &#125; sort(ans+1,ans+top+1);//排序找字典序最小 cout&lt;&lt;ans[1]; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
        <tag>状压dp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF535D 【Tavas and Malekas】]]></title>
    <url>%2F2019%2F05%2F03%2F%E9%A2%98%E8%A7%A3%20CF535D%20%E3%80%90Tavas%20and%20Malekas%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 首先很容易发现答案就是$26​$的“空位个数”次方。空位的个数很显然能够通过极其方便的差分处理出来，我们要处理的仅仅只有判断是否无解。 分两种情况： 第一种，两个串不相交，显然什么关系都没有。 第二种，两个串相交，我们要判断相交部分是不是相同。发现相交的是第一个字符串的后缀，和第二个字符串的前缀，判断这两段是否相同，那么最容易想到的就是$Hash$了。$Hash$在$cf$上极其危险，有人会对着你卡。所以尽量写个双$Hash$即可。 观察到要判断前缀和后缀的关系，那么显然$KMP$也是可以的。$KMP$的$next$数组就是判断以每一位结尾的字符串前缀和后缀有多少位相等的。那么我们就可以用$KMP$算出，哪些长度的重叠部分是满足条件的。举个栗子，串$abababab$，$next[8]=6$，那么重叠部分长度为$6$就是符合条件的，然后再算$next[6]=4$，$next[4]=2$ $\cdots$，所以重叠部分长度为$4,2$都是符合条件的。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")#define mo 1000000007using namespace std;int n,m,p[1000005],len,a[1000005],sum[1000005],vis[1000005];char s[1000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline ll ksm(ll x,ll y)&#123; ll res=1; while(y)&#123; if(y&amp;1) res=res*x%mo; y&gt;&gt;=1; x=x*x%mo; &#125; return res;&#125;signed main()&#123; n=read(),m=read(); scanf("%s",s+1); len=strlen(s+1); int j=0; p[1]=0; for(int i=2;i&lt;=len;i++)&#123;//kmp while(j&gt;0&amp;&amp;s[i]!=s[j+1]) j=p[j]; if(s[i]==s[j+1]) j++; p[i]=j; &#125; for(int i=len;i;i=p[i]) vis[i]=1;//哪些长度的重叠符合条件 for(int i=1;i&lt;=m;i++) a[i]=read(),sum[a[i]]++,sum[a[i]+len]--; for(int i=2;i&lt;=m;i++)&#123; if(a[i]-a[i-1]&lt;len)&#123; if(!vis[a[i-1]+len-a[i]])&#123;//a[i-1]+len-a[i]即重叠长度，很容易手玩得出 printf("0"); return 0; &#125; &#125; &#125; int cnt=0,s=0; for(int i=1;i&lt;=n;i++)&#123; s+=sum[i]; if(s==0) cnt++; &#125; printf("%lld",ksm(26,cnt)); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>Hash</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2051 【[AHOI2009]中国象棋】]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%A2%98%E8%A7%A3%20luoguP2051%20%E3%80%90%5BAHOI2009%5D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 经过多次爆蛋，还是秒切了此题。 一道少数没看题解做的题，哇居然是紫题我好牛逼。 开始不正经的讲题目：很显然发现这是一道动态规划题，先考虑设计状态。 很容易想到的状态是$dp[i][j]$表示前$i$行放上$j$个炮的方案数。但转移时我们就发现，这个状态所包含的信息太少了，从第$i-1$行转移到第$i$行，好像根本无法判断第$i$行怎么放，辣怎么办哩？ 观察到炮的性质：一行或者一列最多只能放两个，放三个就会互相搞基起来。我们想要以行为层次进行转移，那么很显然我们要保存列的状态。 因为一列最多放一个或者两个，辣么我们用$dp[i][j][k]$表示前$i$行，有$j$列只放了一个，有$k$列放了两个的方案数，这个状态就十分的完美啦，完结撒花~ 停停停，这都写了还要讲怎么转移吗？随便$yy$一下就好了啊？ 显然根据我们设计的状态，是以$i$为层次进行转移的，辣么如何从第$i-1$行转移到第$i$行？我们欢快的进行分类讨论，发现情况并不多： 1.第$i$行什么都不放。太愚蠢了。 f[i][j][k]=f[i][j][k]+f[i-1][j][k]2.放1个在空的列。根据状态很容易发现空的列是$m-j-k$。那么方案显然了： f[i][j][k]=f[i][j][k]+f[i-1][j-1][k]\times(m-(j-1)-k)3.放1个在有1个的列。 f[i][j][k]=f[i][j][k]+f[i-1][j+1][k-1]\times(j+1)4.放2个都在空的列。这里就用到排列了，是之前状态乘以$C($之前空的列，$2)$。 f[i][j][k]=f[i][j][k]+f[i-1][j-2][k]\times C(m-(j-2)-k)5.放1个在空的列,1个在有1个的列。同样乘法原理： f[i][j][k]=f[i][j][k]+f[i-1][j][k-1]\times j\times (m-j-(k-1))6.放2个在有1个的列。我一开始愚蠢到忘记考虑这种了。 f[i][j][k]=f[i][j][k]+f[i-1][j+2][k-2]\times C(j+2)初始化很简单：$f[0][0][0]=1$。 完结撒花~，中途记得取模。 还需要代码吗？我想是的：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define hh puts("")#define mo 9999973using namespace std;int n,m,f[105][105][105];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline int C(int aa)&#123;//C(aa,2) return (aa*(aa-1)/2)%mo;&#125;signed main()&#123; n=read(),m=read(); f[0][0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=m;j++) for(int k=0;j+k&lt;=m&amp;&amp;j+k&lt;=2*i;k++)&#123; f[i][j][k]=(f[i][j][k]+f[i-1][j][k])%mo;//什么都不放 if(j&gt;=1) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-(j-1)-k)%mo)%mo;//放1个在空的列 if(k&gt;=1) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1)%mo)%mo;//放1个在有1个的列 if(j&gt;=2) f[i][j][k]=(f[i][j][k]+f[i-1][j-2][k]*C(m-(j-2)-k)%mo)%mo;//放2个都在空的列 if(k&gt;=1) f[i][j][k]=(f[i][j][k]+f[i-1][j][k-1]*j%mo*(m-j-(k-1))%mo)%mo;//放1个在空的列,1个在有1个的列 if(k&gt;=2) f[i][j][k]=(f[i][j][k]+f[i-1][j+2][k-2]*C(j+2)%mo)%mo;//放2个在有1个的列 &#125; int ans=0; for(int i=0;i&lt;=m;i++) for(int j=0;i+j&lt;=m&amp;&amp;(i+j)&lt;=2*n;j++) ans=(ans+f[n][i][j])%mo; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2155 【[SDOI2008]沙拉公主的困惑】]]></title>
    <url>%2F2019%2F04%2F10%2F%E9%A2%98%E8%A7%A3%20luoguP2155%20%E3%80%90%5BSDOI2008%5D%E6%B2%99%E6%8B%89%E5%85%AC%E4%B8%BB%E7%9A%84%E5%9B%B0%E6%83%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 这题真喵喵的毒瘤，写的时候被时空双卡。 为了发泄愤怒，我来水一篇题解 题意：求 $1-n!$ 中与 $m!$ 互质的数的个数 $(m&lt;=n)$ 我们发现小于 $m!$ 的数中，与 $m!$ 互质的数有$φ(m!)$个，那如何求大于 $m!$ 的数中与 $m!$ 互质的数的个数呢？ 引理：若$a,b$互质，则$a+b\times k$与$b$互质。 证明：当$gcd(a,b)=1$时，$gcd(b,a\% b)=1$ $\because a\% b=a-b\times k$ $\therefore gcd(b,a-b\times k)=1$ 得证。 那么对于一个小于 $m!$ 且与 $m!$ 互质的数$x$，$x+1\times m!$，$x+2\times m!$ ……都与 $m!$ 互质。 因为$n&gt;=m$，所以$n!$是$m!$的倍数，那么$1-n!$ 中与 $m!$ 互质的数的个数，根据上面的结论，很显然就是： res=φ(m!)\times \frac{n!}{m!}=m!\times \prod\limits_{i=1}^{k}\left (\dfrac{p_i-1}{p_i}\right)\times \frac{n!}{m!}=n!\times \prod\limits_{i=1}^{k}\left (\dfrac{p_i-1}{p_i}\right)我们用$ans$数组记录最后的式子的右边的东西，$ans[i]$表示$k$到$i$时右边东西的值。$jc[i]$表示$i!$。$ny[i]$表示$i$的逆元。 根据公式，很容易就能写出，答案$=jc[n]\times ans[m]$。预处理出三个数组，就能做到$O(1)$查询，这题就做完了，撒花~。 空间有点紧，不能都开$long \ long$，不该开的就不用开了。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define ll long long#define LL unsigned long long#define hh puts("")using namespace std;int T,top,n,m,ny[10000005],ans[10000005],pr[6000005];bool v[10000005];ll r,jc[10000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;signed main()&#123; scanf("%d%lld",&amp;T,&amp;r); jc[0]=jc[1]=1; ny[0]=ny[1]=1; ans[0]=ans[1]=1; for(int i=2;i&lt;=10000000;i++)&#123; jc[i]=jc[i-1]*(ll)i%r; ny[i]=(ll)(r-r/i)*ny[r%i]%r; if(!v[i]) pr[++top]=i; for(int j=1;j&lt;=top&amp;&amp;i*pr[j]&lt;=10000000;j++)&#123; v[i*pr[j]]=1; if(i%pr[j]==0) break; &#125; &#125; for(int i=2;i&lt;=10000000;i++)&#123; ans[i]=ans[i-1]; if(!v[i]) ans[i]=(ll)ans[i]%r*(i-1)%r*ny[i]%r; &#125; while(T--)&#123; n=read(),m=read(); ll res=(ll)ans[m]%r*jc[n]%r; printf("%lld\n",res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>Luogu</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2303 【[SDOi2012]Longge的问题】]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%A2%98%E8%A7%A3%20luoguP2303%20%E3%80%90%5BSDOi2012%5DLongge%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 好水的蓝题啊，少数没有看题解做的题 题面简洁明了：求$\sum\limits_{i=1}^{n}gcd(i,n)$ 设$gcd(i,n)=d$，则$gcd(i/d,n/d)=1$ $d$显然就是$n$的因数 我们对于每个$d$，要求有多少$i$使得$gcd(i/d,n/d)=1$，设求出有$x$个$i$，那么对答案的贡献就是$d \times x$。为什么是这些贡献？很显然，这些$i$与$n$的$gcd$就是$d$，共$x$个这样的$i$，所以是$d \times x$。 因为满足$gcd(i/d,n/d)=$1的$i/d$的个数就是与$n/d$互质的数，每个$i/d$又对应一个$i$，个数就是$φ(n/d)$。前面说了$d$是$n$的因数，我们枚举所有因数，累加答案即可。 对于每个$φ(n/d)$，$\sqrt{n}$求即可。 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int ans,n;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline int getphi(int x)&#123; int res=x; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; res=res/i*(i-1); while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125;signed main()&#123; n=read(); int sq=sqrt(n); for(int i=1;i&lt;=sq;i++)&#123; if(n%i==0)&#123; ans+=getphi(n/i)*i; if(i*i!=n) ans+=getphi(i)*(n/i); &#125; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3200 【[HNOI2009]有趣的数列】]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%A2%98%E8%A7%A3%20luoguP3200%20%E3%80%90%5BHNOI2009%5D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%88%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 很好的一道思维题。警告：文字较多，没有耐心者勿入。 首先我们命名$a_1,a_3,…,a_{2n-1}$为奇数位，其余为偶数位。观察题目条件：奇数位与偶数位上的数字都满足从左到右递增，相邻的$a_{2i-1},a_{2i}$满足$a_{2i-1}&lt;a_{2i}$。 首先很容易发现，一个偶数位上的数，比它左边的所有偶数位上的数要大，每个偶数位上的数又比它左相邻奇数位上的数要大。这两条信息，我们可以得出，一个偶数位上的数比它左边所有数都要大，那么再概括一下，就是一个偶数位上的数，大于等于这个偶数位的下标。 这个结论并不够我们来得出最后的答案，我们还需要一些结论。 因为数字从左到右，无论奇数位偶数位都满足递增，那么，我们考虑假如我们按$1-2n$的顺序一个一个放数字，我们应该放在哪里？ 很容易发现，我们应该放在最靠左的能放的奇数位或者偶数位上，这样才能保证满足递增。 那还有什么限制呢？我们设已经放了$1-x$的数，$x_1$个放在了奇数位上，$x_2$个放在了偶数位上$(x_1+x_2=x)$。我们想起前面得出的关于偶数位上放数的结论：一个偶数位上的数，大于等于这个偶数位的下标。那什么时候会小于呢？猜想+估摸一下，感觉是$x_2&gt;x_1$？？ 猜想是很**的，作为一个严谨的人，让我们来简单的证一下。 反证： 假设当前情况为$x_2&gt;x_1$，那么显然$x_2&gt;x/2$，同时最后一个偶数位的下标是$2\times x_2$。 因为我们总共只有$x$个数，但由$x_2&gt;x/2$我们得知，$2\times x_2&gt;x$，所以最后一个偶数位不管放什么，都不满足条件，假设不成立。 所以得出结论，按从小到大的顺序放到任意一个数$x$，都满足放在偶数位上的数字个数小于等于放在奇数位上的数字个数。 想到什么？This 这不是完全一样的卡特兰数吗？但这道题好像更麻烦一点，模数不是质数。那么就需要一些求卡特兰数的技巧，参考别的题解即可，几乎都讲了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int n,mo,cnt[2000005],pr[2000005],mn[2000005],top,ans=1;bool v[2000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res=res*x%mo; y&gt;&gt;=1; x=x*x%mo; &#125; return res;&#125;signed main()&#123; n=read(),mo=read(); memset(v,1,sizeof(v)); v[1]=0; for(int i=2;i&lt;=2*n;i++)&#123; if(v[i])&#123; pr[++top]=i; mn[i]=i; &#125; for(int j=1;j&lt;=top&amp;&amp;pr[j]*i&lt;=2*n;j++)&#123; v[pr[j]*i]=0; if(i%pr[j]==0) break; mn[pr[j]*i]=pr[j]; &#125; &#125; for(int i=1;i&lt;=n;i++) cnt[i]=-1; for(int i=n+2;i&lt;=2*n;i++) cnt[i]=1; for(int i=2*n;i&gt;=2;i--)&#123; if(mn[i]&lt;i)&#123; cnt[mn[i]]+=cnt[i]; cnt[i/mn[i]]+=cnt[i]; &#125; &#125; for(int i=2;i&lt;=2*n;i++) if(mn[i]==i) ans=ans*ksm(i,cnt[i])%mo; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP4397 【[JLOI2014]聪明的燕姿】]]></title>
    <url>%2F2019%2F03%2F29%2F%E9%A2%98%E8%A7%A3%20luoguP4397%20%E3%80%90%5BJLOI2014%5D%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 给你一个数$S$，求约数和等于$S$的数。 好像也没什么好说的，主要就两个式子： 1、整数的唯一分解定理 x=\prod_{i=1}^{k} p_{i}^{a_{i}}2、一个数的所有约数和 S=\prod_{i=1}^{k}\left(\sum_{j=0}^{a_{i}} p_{i}^{j}\right)然后发现枚举选了哪些质数，以及这些质数的指数，等于得到了$x$，判断$S$是否符合条件即可。暴力枚举肯定会$T$，那就搜索，因为搜索可以在条件满足时再进入下一层，效率肯定大于枚举。 搜索需要三个参数，$now$，$x$，$s$，分别表示：还剩多少能够分解，当前枚举第$x$个质数，当前是哪个数。 我们知道，搜索满足条件时，就可以得到答案。那么，什么叫满足条件？有两种： 1、若当前数$now$可表示成一个并未搜索过的质数与$1$的和$($设这个质数为$p$，其实就是$p^{0}+p^{1}$ $)$，则$s$与$p$的乘积可以成为答案。 $update$：为什么要这样判？因为我们要处理的数$S$是一个大整数，最大为$2\times 1e9$，显然如果它是一个特别大的质数和另一个数的乘积，我们是无法搜索到那个特别大的质数的，筛的时候也筛不到。但我们知道，对于一个数$S$，大于$\sqrt{S}$的质因数最多只有一个。所以我们分解$S$的时候，只要处理小于等于$\sqrt{S}$的那部分，然后判断剩下的是不是个大质数即可。 2、$now=1$，即当前的数不能再分解。则当前的数$s$可以成为答案。 主要的核心还是搜索，写了注释便于理解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int pr[100005],top=0,ans[100005],cnt;bool v[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline bool pd(int x)&#123; if(x==1) return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0) return 0; return 1;&#125;void dfs(int now, int x, int s)&#123;// 还剩多少能够分解 第x个质数 当前是哪个数 if(now==1)&#123; ans[++cnt]=s; return; &#125; if(pd(now-1)&amp;&amp;now&gt;pr[x]) ans[++cnt]=s*(now-1); for(int i=x;pr[i]*pr[i]&lt;=now;i++)&#123;//枚举下一个选哪个质数 int t=pr[i];//t为次方和的最后一个数 int sum=pr[i]+1;//sum为总次方和 for(;sum&lt;=now;t*=pr[i],sum+=t) if(now%sum==0) dfs(now/sum,i+1,s*t); &#125;&#125;signed main()&#123; memset(v,1,sizeof(v)); v[1]=0; for(int i=2;i&lt;=100000;i++)&#123; if(v[i]) pr[++top]=i; for(int j=1;j&lt;=top&amp;&amp;pr[j]*i&lt;=100000;j++)&#123; v[i*pr[j]]=0; if(i%pr[j]==0) break; &#125; &#125; int x; while(scanf("%lld",&amp;x)!=EOF)&#123; cnt=0; dfs(x,1,1); sort(ans+1,ans+cnt+1); printf("%lld\n",cnt); for(int i=1;i&lt;=cnt;i++) printf("%lld ",ans[i]); if(cnt) hh; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP1345 【[USACO5.4]奶牛的电信Telecowmunication】]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A2%98%E8%A7%A3%20luoguP1345%20%E3%80%90%5BUSACO5.4%5D%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 众所周知，网络流可以求最小割，但割的是割边。本题一眼看就可以知道，题意要求割掉最少的点使起点到终点不连通。 最小割怎么处理点呢？我们想，只要把点取不取转化到边权就好办了。 考虑拆点，把一个点$i$拆成$i$和$i+n$。$i$向$i+n$连一条边权为$1$的边，再把连向这个点的边都连到$i$上，这个点连向其他点的边都连到$i+n$上。那么只要割掉这条边权为$1$的边，就等价于把这个点给割掉了。建完图后就是求最小割的模板了。注意起点是$st+n$而不是$st$。 总的来说，网络流几乎没有裸题，都需要动脑子(看题解)去建图。拆点就是一种比较常见的方法。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define lowbit(x) (x)&amp;(-x)#define oo (1e18)#define ll long long#define LL unsigned long long#define hh puts("")using namespace std;int n,m,cnt=1,tot,ans,st,ed,head[10005],cur[10005],d[10005];struct Edge&#123; int v,nx,s;&#125;e[2000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].s=z; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline bool bfs()&#123; for(int i=0;i&lt;=10000;i++) d[i]=0,cur[i]=head[i]; d[st]=1; queue&lt;int&gt; q; q.push(st); while(!q.empty())&#123; int now=q.front(); q.pop(); for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(e[i].s&amp;&amp;!d[v])&#123; d[v]=d[now]+1; if(v==ed) return 1; q.push(v); &#125; &#125; &#125; return 0;&#125;int dfs(int now,int ma)&#123; if(now==ed)&#123; ans+=ma; return ma; &#125; int used=0,t; for(int i=cur[now];i;i=e[i].nx)&#123; cur[now]=i; int v=e[i].v; if(e[i].s&amp;&amp;d[v]==d[now]+1)&#123; if(t!=dfs(v,min(e[i].s,ma-used)))&#123; used+=t; e[i].s-=t; e[i^1].s+=t; if(used==ma) break; &#125; &#125; &#125; return used;&#125;signed main()&#123; n=read(),m=read(); st=read()+n,ed=read(); for(int i=1;i&lt;=n;i++)&#123; add(i,i+n,1); add(i+n,i,0); &#125; for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(); add(x+n,y,1e9); add(y,x+n,0); add(y+n,x,1e9); add(x,y+n,0); &#125; while(bfs()) dfs(st,1e9); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 bzoj4260 【Codechef REBXOR】]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A2%98%E8%A7%A3%20BZOJ4260%20%E3%80%90Codechef%20REBXOR%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 题目要求一个序列中的两个子段，使这两个子段每段的异或和加起来值最大。 说到异或，我就想到开花$Trie$字典树。 先考虑怎么求一个$l$到$r$子段的异或和$($异或和：所有数异或起来的值$)$： a_l\oplus a_{l+1}\oplus...\oplus a_{r-1} \oplus a_{r}=(a_1\oplus a_2\oplus...\oplus a_{r-1} \oplus a_{r})\oplus(a_1\oplus a_2\oplus...\oplus a_{l-2} \oplus a_{l-1})所以处理出异或前缀和，不断加入$01Trie$树求解即可。 考虑到要求两个子段，用$ls[i],rs[i]$分别表示$1-i$的最大异或子段，$i-n$的最大异或子段。最后扫一遍取$max$即可。代码不长：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define lowbit(x) (x)&amp;(-x)#define oo (1e18)#define ll long long#define LL unsigned long longusing namespace std;int n,a[400005],s[400005],ls[400005],rs[400005],ch[12500000][2],cnt;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void insert(int x)&#123; int now=0; for(int i=30;i&gt;=0;i--)&#123; int t=(x&amp;(1&lt;&lt;i))?1:0; if(!ch[now][t]) ch[now][t]=++cnt; now=ch[now][t]; &#125;&#125;inline int find(int x)&#123; int now=0,res=0; for(int i=30;i&gt;=0;i--)&#123; int t=(x&amp;(1&lt;&lt;i))?0:1; if(ch[now][t])&#123; now=ch[now][t]; res+=(1&lt;&lt;i); &#125; else now=ch[now][!t]; &#125; return res;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); ls[1]=a[1]; insert(a[1]); for(int i=2;i&lt;=n;i++)&#123; ls[i]=max(ls[i-1],find(a[i])); insert(a[i]); &#125; memset(ch,0,sizeof(ch)); cnt=0; rs[n]=a[n]; insert(a[n]); for(int i=n-1;i&gt;=2;i--)&#123; rs[i]=max(rs[i+1],find(a[i])); insert(a[i]); &#125; int ans=0; for(int i=1;i&lt;=n-1;i++) ans=max(ans,ls[i]+rs[i+1]); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>bzoj</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP1344 【[USACO4.4]追查坏牛奶Pollutant Control】]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A2%98%E8%A7%A3%20luoguP1344%20%E3%80%90%5BUSACO4.4%5D%E8%BF%BD%E6%9F%A5%E5%9D%8F%E7%89%9B%E5%A5%B6Pollutant%20Control%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 这是一道很好的套路题。助你掌握新套路。 第一问太愚蠢了，求最小割，学过网络流应该都会。 重点是第二问，求最小割割的最少边数。太难了，默默打开题解，$get$到新套路。 建图时，我们将边的权值乘以$(($一个较大的数$a)+1)$，设新的图的最小割为$newans$，那么原图最小割为$newans/a$，最小割割的最少边数为$newans\%a$。 原理(摘自题解)：因为最小割的边集$E={w_1,w_2…w_n}$中有 w_1+w_2+w_3…+w_n=ans其中$ans$为本来的最小割。 所以必然有： w_1\times a+w_2\times a+w_3\times a…+w_n\times a=ans\times a于是又有： w1\times a+1+w2\times a+1+w3\times a+1…+wn\times a+1=ans\times a+k=newans$k$为最小割的边数，$k&lt;=m&lt;=1000$ 最后得到结论：原图最小割为$newans/a$，最小割割的最少边数为$newans\%a$。 于是这题就解决了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define lowbit(x) (x)&amp;(-x)#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int n,m,cnt=1,tot,ans,st,ed,head[10005],cur[10005],d[10005],base=2003;struct Edge&#123; int v,nx,s;&#125;e[2000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].s=z; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline bool bfs()&#123; for(int i=0;i&lt;=ed;i++) d[i]=0,cur[i]=head[i]; d[st]=1; queue&lt;int&gt; q; q.push(st); while(!q.empty())&#123; int now=q.front(); q.pop(); for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(e[i].s&amp;&amp;!d[v])&#123; d[v]=d[now]+1; if(v==ed) return 1; q.push(v); &#125; &#125; &#125; return 0;&#125;int dfs(int now,int ma)&#123; if(now==ed)&#123; ans+=ma; return ma; &#125; int used=0,t; for(int i=cur[now];i;i=e[i].nx)&#123; cur[now]=i; int v=e[i].v; if(e[i].s&amp;&amp;d[v]==d[now]+1)&#123; if(t=dfs(v,min(e[i].s,ma-used)))&#123; used+=t; e[i].s-=t; e[i^1].s+=t; if(used==ma) break; &#125; &#125; &#125; return used;&#125;signed main()&#123; n=read(),m=read(); st=1,ed=n; for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(),z=read(); add(x,y,z*base+1),add(y,x,0); &#125; while(bfs()) dfs(st,1e16); printf("%lld %lld",ans/base,ans%base); return 0;&#125; 拓展一下，也就是原题$($这题简化过$)$：我们求出了边的数量，但如果要求这些边的编号，又应该怎么做？ 参考了这篇博客： 首先，网络流的核心是从起点通过多条路径到终点，那么，我们可以想出，这每一条合格$($可以从起点流向终点$)$的路径，一定会有其中一条或多条边满流了，那么就代表这条边是这条路径的核心，去掉这条边，整张图的完整流量就会减去这条边的流量，我们称这些边为贡献边。 那么，在最小割所求的最小容量中所割掉的边的集合中，一定全部是贡献边。显然。 那么，怎么求这些边呢$($编号按字典序排并且要最少的边$)$？ 由于这些贡献边控制了流量，所以，我们把它删除掉，再流一遍，会得到一个新的$ans(ans$可能是0$)$，$ans+$这条边的权值$=$不删这条边的最大流，依靠这条等式，就可以去判断了，最后排序即可。]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.20模拟赛T4]]></title>
    <url>%2F2019%2F03%2F20%2F2019.3.20%E6%A8%A1%E6%8B%9F%E8%B5%9BT4%2F</url>
    <content type="text"><![CDATA[传送门 出题人：我本来就不想让你们拿分。。咳咳咳 果然没有拿到分。。自闭 设最大的能通过或运算得到的值为$ma$，则根据$a[i]$的范围，$0\leq ma&lt;(1&lt;&lt;17)$。不是很大，考虑枚举$ma$来求得答案。 设当前枚举$ma$枚举到$now$，我们要求出有多少对$(a,b)$满足$a|b=now$，$(a,b)$的对数大于$0$就说明这个$ma$是符合条件的。$(ma$倒着枚举，一满足条件就退出$)$ 怎么求出$(a,b)$的对数呢？考虑先枚举$a$，发现$a$在二进制下必然是$now$的子集，这里用到一个枚举二进制子集的套路： 假如要枚举$i$的二进制子集，套路代码如下：1for(int x=i;x;x=(x-1)&amp;i) 所有的$x$即为$i$的二进制子集，我也不知道为什么$($因为是套路$)$ 我们枚举出所有的$now$的二进制子集$a$，对于每一个$a$，$now-a$的超集都可以成为答案。当然超集中的数应该是读入的数中有的。 发现我们要预处理出超集，清楚了超集的概念应该很好预处理。对于每个$now$，它的子集的超集数量要加上等于$now$的数的个数。这些数的个数用一个桶记录。 还有一些细节，包括去重等，可见具体代码：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long long#define hh puts("")using namespace std;int n,t[500005],a[500005],x[500005],y[500005],ans1,ans2;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); t[a[i]]++;//t[i]表示i出现的次数(桶) &#125; //下文中集合均为二进制下 for(int i=0;i&lt;(1&lt;&lt;17);i++)&#123; for(int j=i;j;j=(j-1)&amp;i) y[j]+=t[i]; y[0]+=t[i];//y[i]记录i的超集中有多少数字是可行的(也就是读入进来的) &#125; for(int i=(1&lt;&lt;17)-1;i&gt;=1;i--)&#123;//枚举最大值i,对于每个i计算方案数 int tmp=0; for(int j=i;j;j=(j-1)&amp;i) tmp+=t[j]*y[i-j]; //显然,对于一个可以与j进行或运算达到最大值i的数x,i-j是x的子集,所有的x的集合就是i-j的超集 tmp+=t[0]*y[i]; tmp-=t[i];//循环时,当j=i,y[i-j]多包含一次t[i],所以减掉 if(tmp)&#123; ans1=i; ans2=tmp/2; //(a,b)(b,a)的组合都算进去了,所以除以二 break; &#125; &#125; printf("%d %d",ans1,ans2); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2886 【[USACO07NOV]牛继电器Cow Relays】]]></title>
    <url>%2F2019%2F03%2F18%2F%E9%A2%98%E8%A7%A3%20luoguP2886%20%E3%80%90%5BUSACO07NOV%5D%E7%89%9B%E7%BB%A7%E7%94%B5%E5%99%A8Cow%20Relays%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 首先发现是一张连通图，而且只有$100$条边，那么点也很少 编号是乱的，先进行一波离散化，上$map$即可(STL大法好) 离散化后，转化成邻接矩阵，这个矩阵实际上表示的是$i$到$j$只经过$1$条边的最短路矩阵。这时发现，我们要求的答案是一个$st$到$ed$且只经过$n$条边的最短路矩阵。 考虑如何从小矩阵推向大矩阵：设矩阵$A$是一个任意两点经过$x$条边的最短路矩阵，设矩阵$B$是一个任意两点经过$y$条边的最短路矩阵 $A$ $\times$ $B$得到矩阵$C$，那么矩阵$C$是一个经过$(x+y)$条边的矩阵 重载乘法，因为矩阵转移时的实质为$Floyd$松弛：$C(i,j)=min(A(i,k)+B(k,j)) (1&lt;=k&lt;=n)$ 答案就是初始矩阵的$k$次方，矩阵快速幂加速即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int k,m,st,ed,cnt=0;map&lt;int,int&gt; mp;struct matrix&#123; int ma[105][105]; void init()&#123;memset(ma,0x3f,sizeof(ma));&#125;&#125;f,ans;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;matrix mul(matrix a,matrix b)&#123; matrix res; res.init(); for(int kk=1;kk&lt;=cnt;kk++) for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) res.ma[i][j]=min(res.ma[i][j],a.ma[i][kk]+b.ma[kk][j]); return res;&#125;void ksm(int p)&#123; while(p)&#123; if(p&amp;1) ans=mul(ans,f); p&gt;&gt;=1; f=mul(f,f); &#125;&#125;signed main()&#123; k=read(),m=read(),st=read(),ed=read(); f.init(),ans.init(); for(int i=1;i&lt;=m;i++)&#123; int v=read(); int x=read(),y=read(); if(!mp[x]) mp[x]=++cnt; if(!mp[y]) mp[y]=++cnt; f.ma[mp[x]][mp[y]]=f.ma[mp[y]][mp[x]]=min(f.ma[mp[x]][mp[y]],v); &#125; for(int i=1;i&lt;=cnt;i++) ans.ma[i][i]=0; ksm(k); printf("%lld",ans.ma[mp[st]][mp[ed]]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>Luogu</tag>
        <tag>离散化</tag>
        <tag>Floyd</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数学习笔记]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[定义：对于正整数$n$，欧拉函数是小于等于$n$的数中与$n$互质的数的个数。 符号：$φ(n)$表示$n$的欧拉函数，默认$φ(1)=1$。 一些定理： 1.对于一个素数$p$，$φ(p)=p-1$。 证明略。 2.对于两个互质的数$a,b$，$φ(a \times b)=φ(a) \times φ(b)$。$($感谢 $hyj$ 巨佬的指正$)$ 证明：因为$a$与$b$互质，所以$a$与$b$没有共同的质因数。设$a$有$k_a$个质因数，$b$有$k_b$个质因数，因此： \begin{aligned}φ(a)*φ(b)&=a*\prod\limits_{i=1}^{k_a} \left(1-\dfrac{1}{p[i]}\right)*b*\prod\limits_{i=1}^{k_b} \left(1-\dfrac{1}{p[i]}\right)\\&=a*b*\prod\limits_{i=1}^{k_a+k_b} \left(1-\dfrac{1}{p[i]}\right)\\&=φ(a*b)\end{aligned}注：欧拉函数是积性函数，但不是完全积性函数。 $update$：这个证法貌似是错的，因为要用到欧拉函数的公式，但是欧拉函数的公式又要由这个式子推出来。所以只能显然正确了。真的证明我还不会$($我菜爆了$)$，可以参考这里 3.对于一个素数$p$的幂次，如$p^{a}$，有$φ(p^{a})$ $=$ $(p-1)$ $\times$ $p^{a-1}$。 证明：比$p^{a}$小的正整数共$p^{a}-1$个。其中所有$p$的倍数可以表示成$p$ $\times$ $t$ $(t=1,2……p^{a-1}-1)$，即共有$p^{a-1}-1$个数能被$p$整除。因为$p$是质数，所以显然只有这些数不能被$p$整除，剩余的数都与$p$互质。因此，$φ(p^{a})$ $=$ $p^{a}-1$ $-$ $(p^{a-1}-1)$ $=$ $(p-1)$ $\times$ $p^{a-1}$。 4.如果$i\%p=0$，那么$φ(i\times p)=φ(i)\times p$。 证明：懒了不想写，好像没多大用。 求欧拉函数： 1.求单个欧拉函数：$φ(x)$ $=x$ $\times$ $\prod\limits_{i=1}^k \left(1-\dfrac{1}{p[i]}\right)$ 其中$p[1],p[2]……p[k]$为$x$的所有质因子 证明：首先，由整数的唯一分解定理可得，$x$ $=$ $p[1]^{a_1}$ $\times$ $p[2]^{a_2}$ $\times$ $……$ $\times$ $p[k]^{a_k}$。显然$p[1]^{a_1}$，$p[2]^{a_2}$，$……$，$p[k]^{a_k}$之间两两互质。那么，根据定理$2,3$： \begin{aligned}φ(x)&=φ(p[1]^{a_1})*φ(p[2]^{a_2})*......*φ(p[k]^{a_k})\\&=(p[1]^{a_1}*(1-\frac{1}{p[1]}))*(p[2]^{a_2}*(1-\frac{1}{p[2]}))*......* (p[k]^{a_k}*(1-\frac{1}{p[k]}))\\&=(p[1]^{a_1}*p[2]^{a_2}*......*p[k]^{a_k})*(1-\frac{1}{p[1]})*(1-\frac{1}{p[2]})*......*(1-\frac{1}{p[k]})\\&=x*\prod\limits_{i=1}^k \left(1-\dfrac{1}{p[i]}\right)\end{aligned}代码：1234567891011inline int getphi(int x)&#123; int res=x; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; res=res/i*(i-1);//通分公式大括号内内容即可 while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125; 2.线性筛欧拉函数：方法类似于筛素数，其实并不难，在筛素数的同时进行筛欧拉函数。 用到上面的1，2，4定理。 代码： 1234567891011121314for(int i=2;i&lt;=n;i++)&#123; if(!v[i])&#123; phi[i]=i-1; pr[++top]=i; &#125; for(int j=1;j&lt;=top&amp;&amp;i*pr[j]&lt;=n;j++)&#123; v[i*pr[j]]=1; if(i%pr[j]==0)&#123; phi[i*pr[j]]=phi[i]*pr[j]; break; &#125; else phi[i*pr[j]]=phi[i]*phi[pr[j]]; &#125;&#125; 欧拉定理：若$gcd(a,m)=1​$，那么$a^{φ(m)}​$ $\equiv​$ $1 \pmod m​$。 证明：找欧拉去]]></content>
      <tags>
        <tag>数论</tag>
        <tag>学习笔记</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3320 【[SDOI2015]寻宝游戏】]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%A2%98%E8%A7%A3%20luoguP3320%20%E3%80%90%5BSDOI2015%5D%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 看到建虚树的做法？？？不会 这题要求每一次加减操作都计算答案，那么我们考虑加入一个点的贡献。 慢慢分析：首先一个点或者没有点，肯定没有贡献，为0。 然后是两个点，随便从一个点开始，走到另一个点再返回，贡献为2 $\times$ $dis(x,y)$。 回忆一下树上两点距离：$x$到$y$的距离$=$ $x$到根的距离$+$ $y$到根的距离$-$ $lca(x,y)$到根的距离$\times$ 2。($lca$想怎么求怎么求) 再增加一个点呢？树上有3个点，怎么走能使距离最短？应该是按遍历时的时间戳走咯。假设时间戳为1，2，3，那么贡献就是1-&gt;2 $+$ 2-&gt;3 $+$ 3-&gt;1。(箭头表示两点之间距离) 那么不管几个点，我们发现按时间戳走肯定最快。所以考虑维护加入点的时间戳。蒟蒻我不会$splay$，只能甩出一手$STL$大法$set$。(STL大法好) 每插入一个元素，考虑增加的贡献，是先删去它时间戳($set$里面)左边和右边的贡献，再加上它和左边以及它和右边的贡献。删去一个元素同理。这题做完，对$set$的使用以后就会很熟练了。 注意特判一个点的情况以及开$long\ long$。 上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define ite set&lt;int&gt;::iterator#define ls(x) (x&lt;&lt;1)#define rs(x) (x&lt;&lt;1|1)#define hh puts("")using namespace std;int n,m,cnt,head[100005],dfn[100005],bz[100005][20],dis[100005],vis[100005],dep[100005],ans;set&lt;int&gt; s;struct Edge&#123; int v,nx,s;&#125;e[200005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].nx=head[x]; e[cnt].s=z; head[x]=cnt;&#125;void dfs(int now,int fa)&#123; dfn[now]=++cnt;//时间戳 vis[cnt]=now;//dfs序 dep[now]=dep[fa]+1; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(v==fa) continue; dis[v]=dis[now]+e[i].s; bz[v][0]=now; dfs(v,now); &#125;&#125;inline ite lef(ite it)&#123; if(it==s.begin()) return --s.end(); return --it;&#125;inline ite rig(ite it)&#123; if(it==--s.end()) return s.begin(); return ++it;&#125;inline int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=17;i&gt;=0;i--)&#123; if(dep[bz[x][i]]&gt;=dep[y]) x=bz[x][i]; &#125; if(x==y) return x; for(int i=17;i&gt;=0;i--) if(bz[x][i]!=bz[y][i]) x=bz[x][i],y=bz[y][i]; return bz[x][0];&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;i++)&#123; int x=read(),y=read(),z=read(); add(x,y,z); add(y,x,z); &#125; cnt=0; dis[1]=0; dfs(1,0); for(int k=1;k&lt;=17;k++) for(int i=1;i&lt;=n;i++) bz[i][k]=bz[bz[i][k-1]][k-1]; for(int i=1;i&lt;=m;i++)&#123; int x=read(); if(!s.count(dfn[x]))&#123; if(s.size())&#123; ite it=s.lower_bound(dfn[x]); if(it==s.end()) it=s.begin(); ite L=lef(it); int lca1=LCA(vis[*it],vis[*L]); int lca2=LCA(vis[*it],x); int lca3=LCA(vis[*L],x); ans-=dis[vis[*it]]+dis[vis[*L]]-2*dis[lca1]; ans+=dis[vis[*it]]+dis[x]-2*dis[lca2]; ans+=dis[vis[*L]]+dis[x]-2*dis[lca3]; &#125; s.insert(dfn[x]); printf("%lld\n",ans); continue; &#125; else&#123; ite it=s.find(dfn[x]); ite L=lef(it),R=rig(it); int lca1=LCA(x,vis[*L]); int lca2=LCA(x,vis[*R]); int lca3=LCA(vis[*L],vis[*R]); ans-=dis[x]+dis[vis[*L]]-2*dis[lca1]; ans-=dis[x]+dis[vis[*R]]-2*dis[lca2]; ans+=dis[vis[*L]]+dis[vis[*R]]-2*dis[lca3]; s.erase(dfn[x]); printf("%lld\n",ans); continue; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>LCA</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2161 【[SHOI2009]会场预约】]]></title>
    <url>%2F2019%2F03%2F08%2F%E9%A2%98%E8%A7%A3%20luoguP2161%20%E3%80%90%5BSHOI2009%5D%E4%BC%9A%E5%9C%BA%E9%A2%84%E7%BA%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 线段树好题 。转换题意。将操作看成染色：操作$A$，即统计一段区间内颜色的种类数，并将这个区间修改为同一个颜色。操作$B$，统计整颗线段树上还剩下多少种颜色。 考虑如何用线段树实现这一操作：对于操作$A$，明显就是一个查询$-&gt;$覆盖的操作。对于查询，考虑在修改时进行查询。我们用一个$col[k]$数组维护一段区间的颜色是否为同一个。若为同一个，我们覆盖掉，并使$delans$++$(delans$表示拒绝掉的预约数$)$，否则，分左右两段递归修改。答案即$delans$。 这时有一个问题：若一种颜色一段在修改的区间内，一段在修改的区间外，怎么处理？根据题意要求：对于新的预约操作，只要与先前预约有冲突，就全部拒绝掉。那就再设计一个$del$数组，记录一种颜色是否被删掉，就可以做到只要一种颜色有一段在区间内，就能保证它被全部删掉。 操作$B$相对简单很多，维护一个全局颜色数$ans$，每次$A$操作染色，显然先使$ans$++$($多一种颜色$)$，在染色时，每拒绝掉一个预约，$ans$- -即可。然后操作$B$就要求输出$ans$。 完结撒花~~ 哦对，线段树标配$tag$数组就代表该区间的颜色，$tag$为$0$时表示没有颜色，无需下传。下传时的细节：既然下传了，那么显然区间不是同色，$col[k]$赋为$0$。显然原因：下传操作的进行，是因为当前区间不完全在修改区间范围内$($否则就直接$change$并且$return$了$)$，那么当前区间一部分在修改区间范围内，一部分不在，显然不同色。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define ll long long#define LL unsigned long long#define ls(x) x&lt;&lt;1#define rs(x) x&lt;&lt;1|1#define hh puts("")using namespace std;int n,col[400005],maxx,cnt,ans,del_cnt=0;int del[400005],tag[400005];struct Q&#123; int l,r,opt;&#125;q[200005];void build(int l,int r,int k)&#123; col[k]=1;//col[k]表示线段树中的k区间颜色都相同(把预约看成染色) if(l==r) return; int mid=(l+r)&gt;&gt;1; build(l,mid,ls(k)); build(mid+1,r,rs(k));&#125;void push_down(int l,int r,int k)&#123; col[k]=0; if(!tag[k]) return; tag[ls(k)]=tag[k]; tag[rs(k)]=tag[k]; tag[k]=0;&#125;void change(int l,int r,int v,int k)&#123; if(col[k])&#123; if(tag[k]&amp;&amp;!del[tag[k]])&#123; del_cnt++; ans--; &#125; del[tag[k]]=1; tag[k]=v; return; &#125; int mid=(l+r)&gt;&gt;1; change(l,mid,v,ls(k)); change(mid+1,r,v,rs(k)); col[k]=1,tag[k]=v;&#125;void update(int l,int r,int x,int y,int v,int k)&#123;//将x~y区间内所有颜色都变成v if(x&lt;=l&amp;&amp;r&lt;=y)&#123; change(l,r,v,k); return; &#125; push_down(l,r,k); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,x,y,v,ls(k)); if(mid+1&lt;=y) update(mid+1,r,x,y,v,rs(k));&#125;signed main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; char rd[5]; scanf("%s",rd+1); if(rd[1]=='A')&#123; q[i].opt=1; scanf("%d%d",&amp;q[i].l,&amp;q[i].r); maxx=max(maxx,q[i].r); &#125; else q[i].opt=2; &#125; build(1,maxx,1); for(int i=1;i&lt;=n;i++)&#123; if(q[i].opt==1)&#123; ans++; del_cnt=0; update(1,maxx,q[i].l,q[i].r,++cnt,1); printf("%d\n",del_cnt); &#125; else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP1772 【[ZJOI2006]物流运输】]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%A2%98%E8%A7%A3%20luoguP1772%20%E3%80%90%5BZJOI2006%5D%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 模拟赛居然考了这道题，前一天刚看过，结果看了舍不得(不会)做，结果只骗到30pt 讲课人：很容易想到最短路+$dp$(我靠一点都不容易) 模拟赛后分析，才知道是处理出第i天到第j天都走同一条最短路的花费为$co[i][j]$ 然后进行$dp$，$dp[i]$表示前i天的最小花费 转移方程很好想:$dp[i]$ $=$ $min$ $($ $dp[j]$ $+$ $co[j+1][i]$ $\times$ $(i-j)$ $+$ $k$ $)$，预处理要赋值为$co[1][i]$ $\times$ $i$ $dp$方程的意思，即在第$j+1$天改变路线，第$j+1$天~第$i$天都走同一条路线 那么如何处理$co[i][j]$? 很简单，对于每一个$(i,j)$，先把$i$到$j$天之间封闭的码头全部设为不可走，跑一遍最短路即可，初值为无穷 数据辣么小，跑几遍以及跑什么都没关系嘤嘤嘤 那我们就十分愉♂快的解决了此题~~~ 愉♂快的提交了然后居然只有90pt 原谅我无耻的打开题解 啊啊啊原来要开$long$ $long$(明明数据辣么小) 献上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define soo (1e8)#define ll long longusing namespace std;int d,cnt,head[25],dis[25],vis[25],cant_vis[25];ll co[105][105],dp[105];int n,m,k,ee,cl[25][105];struct Edge&#123; int v,nx,s;&#125;e[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].s=z; e[cnt].nx=head[x]; head[x]=cnt;&#125;void spfa()&#123;//爱跑什么跑什么 for(int i=1;i&lt;=m;i++) dis[i]=soo,vis[i]=0; queue&lt;int&gt; q; dis[1]=0; q.push(1); while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];i;i=e[i].nx)&#123; int v=e[i].v; if(cant_vis[v]) continue; if(dis[v]&gt;dis[x]+e[i].s)&#123; dis[v]=dis[x]+e[i].s; if(!vis[v])&#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125;&#125;signed main()&#123; n=read(),m=read(),k=read(),ee=read(); for(int i=1;i&lt;=ee;i++)&#123; int x=read(),y=read(),z=read(); add(x,y,z); add(y,x,z); &#125; d=read(); for(int i=1;i&lt;=d;i++)&#123; int t=read(),x=read(),y=read(); for(int j=x;j&lt;=y;j++) cl[t][j]=1; &#125; //cl[i][j]表示第i个码头在第j天不能走 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; memset(cant_vis,0,sizeof(cant_vis)); for(int r=i;r&lt;=j;r++) for(int l=1;l&lt;=m;l++) if(cl[l][r]) cant_vis[l]=1; spfa(); co[i][j]=dis[m]; &#125; memset(dp,0x7f,sizeof(dp)); for(int i=1;i&lt;=n;i++)&#123; dp[i]=(ll)co[1][i]*i; for(int j=i-1;j&gt;=0;j--) dp[i]=min(dp[i],dp[j]+co[j+1][i]*(i-j)+k); &#125; printf("%lld",dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF773D 【Perishable Roads】]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%A2%98%E8%A7%A3%20CF773D%20%E3%80%90Perishable%20Roads%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 简述一下题意：给出$n$个点的完全图，对于完全图中的每个点$i$，$i$作为终点时，要使其他每个点到点$i$的“距离”和最小，对于每个点都输出这个最小值。这里的“距离”是指对于其他每个点，那个点到点$i$路径上的最小值。且对于每个点$i$，计算答案时应保证图内每条边的方向一定。（有点难解释，可以参考原文） 题意很难表述清楚，建议看懂原题后再来看此题解。 考虑对于每个终点$i$，最后连接所有点后图的形态，应该是一棵树接上一条链。如图： 我会贪心&amp;&amp;搜索！从终点开始倒搜，对于当前搜到的点$now$，每次找到未$vis$的且与$now$相连的边权最小的点，向那个点继续搜。 很显然这个想法是非常非常错误的，直接排除 考虑优化贪心：既然让每个点到终点路径上的最小边权和最小，那么很容易想到将所有点都连到边权最小的边的一端，再从这个点连向终点。$($下文我们将这个点称为“最小点”$)$ 但这个还是错误的，如果连向终点的那条边权值特别大$(INF)$，那么答案就会非常劣。如图： 那怎么办呢？我们就考虑让“最小点”去间接的连向终点，即从那些直接连向“最小点”的点中取一些出来，与“最小点”构成一条链，使这一条链加上那棵树的答案更优。我们称这条链$($起点为最小点,终点为$t$ $)$的答案为$dis[t]$。如图： 怎么计算答案呢？我们设那条链上除终点外有$x$个点，那么那棵树上就有$n-1-x$个点，设最小边长度为$minn$，那么答案为$dis[t]$+$minn$ $\times$ $(n-1-x)$。 这个$x$很难计算，考虑消去。即计算$dis[t]$前先对所有边权减去一个$minn$，设新链答案为$dis’[t]$，那么答案会变成$($ $dis’[t]$+$minn$ $\times$ $x$ $)$+$minn$ $\times$ $(n-1-x)$，即$dis’[t]$+$minn$ $\times$ $(n-1)$，$x$就消去了。所以我们计算$dis’[t]$即可。 因为要求最优解，我们跑最短路求$dis$ $($定义见上$)$。一开始的状态是上面图2，即向终点直接连边，所以赋为终点与最小点的边权$($详见代码$)$。还有一种状态，即考虑那条链上有3个点。设加入的为点$j$，那么链的答案可能为最小点到终点的答案加上$j$到终点的答案，即$f[i][j]*2$ $($ $f$数组为邻接矩阵，$i$是终点 $)$。最后$dij$松弛即可$($模板$)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int n,f[3005][3005],vis[3005],dis[3005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void write(int x)&#123; if(x&lt;0)&#123;putchar('-');x=-x;&#125; if(x&gt;9)write(x/10); putchar(x%10+48);&#125;void dij(int st)&#123; for(int i=1;i&lt;=n;i++)&#123; dis[i]=f[st][i]; for(int j=1;j&lt;=n;j++) if(i!=j) dis[i]=min(dis[i],f[i][j]*2); &#125; vis[st]=1; for(int i=1;i&lt;=n-1;i++)&#123; int minn=2e9+1,k; for(int j=1;j&lt;=n;j++) if(!vis[j]&amp;&amp;dis[j]&lt;minn)&#123; minn=dis[j]; k=j; &#125; vis[k]=1; for(int j=1;j&lt;=n;j++) if(!vis[j]) dis[j]=min(dis[j],dis[k]+f[j][k]); &#125;&#125;int main()&#123; int minn=2e9+1,k; n=read(); for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=n-i;j++)&#123; f[i][i+j]=f[i+j][i]=read(); if(f[i][i+j]&lt;minn)&#123; minn=f[i][i+j]; k=i; &#125; &#125; for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=n-i;j++)&#123; f[i][i+j]-=minn; f[i+j][i]=f[i][i+j]; &#125; dij(k); for(int i=1;i&lt;=n;i++) printf("%d ",dis[i]+minn*(n-1)); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.2模拟赛T2]]></title>
    <url>%2F2019%2F03%2F02%2F2019.3.2%E6%A8%A1%E6%8B%9F%E8%B5%9BT2%2F</url>
    <content type="text"><![CDATA[传送门 这是一道经典套路题。 ——讲课人同余最短路，第一次听说这种东西嘤嘤嘤，墨墨的等式那题也是一样 我学过语文！（丢人）题意一看就是让你求一个数能不能被若干个给你的数组合出来，考虑背包 我会背包！完全背包裸题啊是不是？ 我靠怎么询问这么大，背包它死了 我会套路！终于步入正轨 首先可以发现一个很简单的套路推论：取$a[i]$ $(1&lt;=i&lt;=n)$中的最小值为$mn$，如果$x$可以被构造出来，那么$x$ $+$ $mn$ $\times$ $k$也可以被构造出来。（正确性显然） 我们定义一个$dis[x]$ ($0$ $&lt;=$ $x$ $&lt;$ $mn$)为最小的能构造出的$x$ $+$ $mn$ $\times$ $k$ ($k&gt;=0$ 且 $k$为整数) 那么对于任何一个数$t$，只要$t$大于等于$dis[t$ $\%$ $mn]$，那么显然$t$可以被构造$($需要意会$)$ 然后我们的问题就是如何求$dis$数组了，哈哈哈名字都叫$dis$那肯定是最短路了 数据这么小那直接$SPFA$乱搞咯$($这种题卡不了$SPFA$的$)$ 首先$dis[0]=0$，即构造$0$不需要选任何东西，然后每次从队列中取出一个去松弛其他点。设当前取出的为$x$，枚举每个$a[i]$去松弛$dis[(x+a[i])$ $\%$ $mn]$，其他都是常规写法 至此我们解决完了，上代码：$($超级短好不好$)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ll long long#define soo (1e9)#define oo (1e18)using namespace std;int n,a[5005],m,mo,vis[50005],dis[50005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void spfa()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q; dis[0]=0; q.push(0); while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=0;i&lt;n;i++)&#123; if(dis[(x+a[i])%mo]&gt;dis[x]+a[i])&#123; dis[(x+a[i])%mo]=dis[x]+a[i]; if(!vis[(x+a[i])%mo])&#123; vis[(x+a[i])%mo]=1; q.push((x+a[i])%mo); &#125; &#125; &#125; &#125;&#125;signed main()&#123; n=read(); for(int i=0;i&lt;n;i++) a[i]=read(); sort(a,a+n); mo=a[0]; spfa(); m=read(); for(int i=1;i&lt;=m;i++)&#123; int qu=read(); if(qu&lt;dis[qu%mo]) puts("NIE"); else puts("TAK"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>模拟赛</tag>
        <tag>最短路</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块学习笔记]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[分块学习笔记及入门题选讲分块是一个很暴力的算法！咳咳先不提这个。。。 啥是分块：分块是一个很暴力的算法。分块将所有数据分为若干个块，维护块内信息，使得块内的查询是$O(1)$的，而总的询问就可以看做若干个块询问的总和。一般来讲，块的大小常设为$sqrt(n)$，但实际上块的大小可以任意自定，通过调试来尽可能让复杂度更优。 图： 为什么要分块：因为。。分块是一个很暴力的算法。它可以完成几乎所有区间更新和区间查询问题$($考场骗分利器$)$。对于小数据，可能效率与线段树相似。虽然大数据可能效率较低，但有些题的确只能用分块做$($神仙不管$)$。总之，分块的适用性比线段树要广，毕竟是暴力算法 分块实现的基本框架：划分块，预处理，操作或查询。 操作或查询通常为4步： 1.判断要操作或是查询的区间是否在一个块内 2.若在一个块内，暴力操作或查询 3.若不在一个块内，将除了最左边和最右边这两个块外其余的块进行整体的操作，即直接对块打上修改标记之类的 4.单独暴力处理最左边的块和最右边的块 分块的基础即建块，类比线段树建树。用$size$表示每一块的大小，$num$表示一共几块，$belong[i]$表示原序列中第$i$个元素在第几块，$l[i],r[i]$分别表示第$i$块的左端点和右端点。上代码：1234567891011void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++;//除不尽说明多出一块边角料 for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n;//最后一块大小可能不为size,右边界特殊处理 &#125; 来一道基础题：给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，单点查值。$(1\leq n\leq 50000)$ LOJ数列分块1 这种题当然可以各种姿势水过去，但我们要学习分块，所以就分块咯。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int n,size,num,belong[100005],l[10005],r[10005],tag[10005],w[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++; for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n; &#125;void add(int x,int y,int v)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) w[i]+=v;//左边边角块 if(belong[x]!=belong[y])&#123;//不在同一个块 for(int i=(belong[y]-1)*size+1;i&lt;=y;i++)//右边边角块 w[i]+=v; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]+=v;//块整体打标记&#125;int query(int x)&#123; return w[x]+tag[belong[x]];&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(); for(int i=1;i&lt;=n;i++)&#123; int opt=read(),x=read(),y=read(),v=read(); if(opt==0) add(x,y,v); else printf("%d\n",query(y)); &#125; return 0;&#125; 分块也可以水数据小的线段树，LOJ数列分块412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n,m,size,num,belong[100005],l[10005],r[10005],sum[10005],tag[10005],w[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++; for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n;&#125;void add(int x,int y,int v)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) w[i]+=v;//左边边角块 sum[belong[x]]+=(min(y,r[belong[x]])-x+1)*v; if(belong[x]!=belong[y])&#123;//不在同一个块 for(int i=(belong[y]-1)*size+1;i&lt;=y;i++) w[i]+=v; sum[belong[y]]+=(y-((belong[y]-1)*size+1)+1)*v; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]+=v,sum[i]+=v*size;&#125;int query(int x,int y)&#123; int res=0; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) res+=w[i]+tag[belong[x]]; if(belong[x]!=belong[y])&#123; for(int i=(belong[y]-1)*size+1;i&lt;=y;i++) res+=w[i]+tag[belong[y]]; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) res+=sum[i]; return res;&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(); for(int i=1;i&lt;=n;i++) sum[belong[i]]+=w[i]; for(int i=1;i&lt;=m;i++)&#123; int opt=read(),x=read(),y=read(); if(opt==1)&#123; int v=read(); add(x,y,v); &#125; else printf("%d\n",query(x,y)); &#125; return 0;&#125; 分块咕了好久了，今天应该会更吧(确信 LOJ数列分块2： 给你一个序列，要求资瓷区间加，以及区间查询小于某个数的元素个数。序列长度$&lt;=50000$ 分块怎么考虑？要查询小于某个数的个数，我们可以一个块一个块查，最后把答案合并起来。 那么一个块内怎么查小于某个数的元素个数呢？显然在块内二分，查到第一个大于等于这个数的位置，这个位置的左边一个位置到这个块的左边界就是这个块的答案。二分需要满足单调性，那我们就时刻维护块内元素有序即可。 已经解决了查询的问题，修改还不方便？用分块的基本套路：左右边角块暴力加，中间完整块打标记。我们发现中间完整块整体加一个数，仍旧保持有序，左右暴力加后变成无序，所以加完要再排一遍序。 照着这个思路写完，爆弹了，反复检查没有看出锅，不知道错在哪里。突然发现一个问题：如果我们只用一个数组，排完序后会打乱原有顺序，导致我们想加的数的位置不在原来位置上。 放张图理解一下： 假如这是原来的每个位置上的值（红线代表划分的块），排过序后，变成这样： 这时我们想在位置3上加上一个数（注意是位置），比如加2。按照之前的思路，我们会在当前的位置（第二张图）3上加2，也就是给3加上2，则第一个块变成1,2,5。但实际上，我们应该在第一张图的位置3上加2，第一个块应该是2,3,3，那怎么处理这种情况？也很简单，保留一下原序列，排序在另一个数组上排序，而操作在原序列上操作（原序列不排序）。这样就不会有加错位置的问题了。可以见代码（原序列是t，用来排序的是w）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")using namespace std;int n,w[50005],belong[50005],sz[10005],t[50005],num,size,tag[10005],l[10005],r[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void build()&#123; size=sqrt(n); num=n/size; if(n%size) num++; for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n; for(int i=1;i&lt;=num;i++) sort(w+l[i],w+r[i]+1);&#125;inline void add(int x,int y,int v)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) t[i]+=v;//在原序列上加 for(int i=l[belong[x]];i&lt;=r[belong[x]];i++) w[i]=t[i]; sort(w+l[belong[x]],w+r[belong[x]]+1); if(belong[x]!=belong[y])&#123; for(int i=l[belong[y]];i&lt;=y;i++) t[i]+=v; for(int i=l[belong[y]];i&lt;=r[belong[y]];i++) w[i]=t[i]; sort(w+l[belong[y]],w+r[belong[y]]+1); &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]+=v;&#125;inline int query(int x,int y,int v)&#123; int res=0,pos; for(int i=x;i&lt;=min(y,r[belong[x]]);i++)&#123; if(t[i]+tag[belong[x]]&lt;v)//对原序列查询 res++; &#125; if(belong[x]!=belong[y])&#123; for(int i=l[belong[y]];i&lt;=y;i++) if(t[i]+tag[belong[y]]&lt;v) res++; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++)&#123; pos=lower_bound(w+l[i],w+r[i]+1,v-tag[i])-w; pos--;//二分找到的是第一个大于等于的，左边一位就是小于的 res+=pos-l[i]+1; &#125; return res;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),t[i]=w[i]; build(); for(int i=1;i&lt;=n;i++)&#123; int opt=read(),L=read(),R=read(),c=read(); if(opt==0) add(L,R,c); else printf("%lld\n",query(L,R,c*c)); &#125; return 0;&#125; LOJ数列分块3： 给你一个序列，要求资瓷区间加，以及区间查询小于某个数的最大的数。序列长度$&lt;=100000$ 做完2再做3发现是一样的题，查询时改为取$max$即可： 代码几乎和2一样：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")using namespace std;int n,w[100005],belong[100005],sz[10005],t[100005],num,size,tag[10005],l[10005],r[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void build()&#123; size=sqrt(n); num=n/size; if(n%size) num++; for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n; for(int i=1;i&lt;=num;i++) sort(w+l[i],w+r[i]+1);&#125;inline void add(int x,int y,int v)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) t[i]+=v; for(int i=l[belong[x]];i&lt;=r[belong[x]];i++) w[i]=t[i]; sort(w+l[belong[x]],w+r[belong[x]]+1); if(belong[x]!=belong[y])&#123; for(int i=l[belong[y]];i&lt;=y;i++) t[i]+=v; for(int i=l[belong[y]];i&lt;=r[belong[y]];i++) w[i]=t[i]; sort(w+l[belong[y]],w+r[belong[y]]+1); &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]+=v;&#125;inline int query(int x,int y,int v)&#123; int res=-1e15,pos; for(int i=x;i&lt;=min(y,r[belong[x]]);i++)&#123; if(t[i]+tag[belong[x]]&lt;v) res=max(res,t[i]+tag[belong[x]]); &#125; if(belong[x]!=belong[y])&#123; for(int i=l[belong[y]];i&lt;=y;i++) if(t[i]+tag[belong[y]]&lt;v) res=max(res,t[i]+tag[belong[y]]); &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++)&#123; pos=lower_bound(w+l[i],w+r[i]+1,v-tag[i])-w; pos--; if(pos&gt;=l[i]) res=max(res,w[pos]+tag[i]); &#125; return res;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),t[i]=w[i]; build(); for(int i=1;i&lt;=n;i++)&#123; int opt=read(),L=read(),R=read(),c=read(); if(opt==0) add(L,R,c); else&#123; int t=query(L,R,c); if(t==-1e15) puts("-1"); else printf("%lld\n",t); &#125; &#125; return 0;&#125; LOJ数列分块5： 给你一个序列，要求资瓷区间开方，区间求和。序列长度$&lt;=50000$ 做过$GSS4$，就知道做法了，只不过线段树改分块而已。 发现一个数开方最多开6次，当一段序列最大值为1，显然不需要再开方，分块维护区间和，区间最大值，当区间最大值大于1暴力开方。维护什么应该是基本操作：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")using namespace std;int n,w[50005],size,num,belong[50005],l[10005],r[10005],ma[10005],sum[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void build()&#123; size=sqrt(n); num=n/size; if(n%size) num++; for(int i=1;i&lt;=n;i++)&#123; belong[i]=(i-1)/size+1; ma[belong[i]]=max(ma[belong[i]],w[i]); sum[belong[i]]+=w[i]; &#125; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n;&#125;inline void sq(int x,int y)&#123; if(ma[belong[x]]&gt;1)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++)&#123; sum[belong[i]]-=w[i]; w[i]=sqrt(w[i]); sum[belong[i]]+=w[i]; &#125; ma[belong[x]]=0; for(int i=l[belong[x]];i&lt;=r[belong[x]];i++) ma[belong[x]]=max(ma[belong[x]],w[i]); &#125; if(belong[x]!=belong[y])&#123; if(ma[belong[y]]&gt;1)&#123; for(int i=l[belong[y]];i&lt;=y;i++)&#123; sum[belong[y]]-=w[i]; w[i]=sqrt(w[i]); sum[belong[y]]+=w[i]; &#125; ma[belong[y]]=0; for(int i=l[belong[y]];i&lt;=r[belong[y]];i++) ma[belong[y]]=max(ma[belong[y]],w[i]); &#125; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++)&#123; if(ma[i]&gt;1)&#123; ma[i]=0; for(int j=l[i];j&lt;=r[i];j++)&#123; sum[i]-=w[j]; w[j]=sqrt(w[j]); ma[i]=max(ma[i],w[j]); sum[i]+=w[j]; &#125; &#125; &#125;&#125;inline int query(int x,int y)&#123; int res=0; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) res+=w[i]; if(belong[x]!=belong[y]) for(int i=l[belong[y]];i&lt;=y;i++) res+=w[i]; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) res+=sum[i]; return res;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(); for(int i=1;i&lt;=n;i++)&#123; int opt=read(),L=read(),R=read(),cccc=read(); if(opt==0) sq(L,R); else printf("%lld\n",query(L,R)); &#125; return 0;&#125; LOJ数列分块6： 给定一个序列，资瓷插入元素，以及查询某一位置元素的值。 用$vector$自带的$insert$函数水过去了$($STLnb$)$，当然每一次$insert$都是$O(n)$的，为什么我们直接插入没有被卡？很简单，因为数据随机。我们考虑用分块怎么做。 如果用分块，口胡一下，代码没写：我们用$vector$来存同一个块内的元素，对于插入操作，先根据每一块的大小，找到要插元素应该插入的块，然后利用$vector$的$insert$函数进行插入。查询同理。 这时有一个问题，会有sangxinbingkuang的出题人来卡你，怎么卡？在同一个块内不断插入元素，使一个块变的特别大。怎么办？ 那我们就限定一个块大小的阈值，超过这个阈值，我们重新分块即可。这样就可以保证复杂度正确。 还是给一下暴力代码（逃：1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n;vector&lt;int&gt; v;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) v.push_back(read()); for(int i=1;i&lt;=n;i++)&#123; int opt=read(),l=read(),r=read(),c=read(); if(opt==0) v.insert(v.begin()+l-1,r); else printf("%d\n",v[r-1]); &#125; return 0;&#125; LOJ数列分块7： 给你一个序列，要求资瓷区间加，区间乘，单点求值。序列长度$&lt;=100000$ 打两个标记，加法标记和乘法标记。区间操作时，如果是边角块，我们对整个块标记全部下放，然后暴力修改边角。如果是整块，分两种情况：先乘后加，先加后乘。 先乘后加，对两个标记分别操作即可，互不干扰。但如果先加后乘，则乘法对加法标记有影响。设原来乘法标记为$a$，加法标记为$b$，一个数为$x$，则原来值为$ax+b$，乘上一个数$k$，则值变成$akx+bk$，所以乘的时候，对加法标记也进行乘操作即可。 具体见代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define int long long#define hh puts("")#define mo 10007using namespace std;int n,size,num,w[100005],belong[100005],l[10005],r[10005],tag_mul[10005],tag_add[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void build()&#123; size=sqrt(n); num=n/size; if(n%size) num++; for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; tag_mul[i]=1;//注意乘法标记一开始是1不是0 tag_add[i]=0; &#125; r[num]=n;&#125;inline void add(int x,int y,int v)&#123; for(int i=l[belong[x]];i&lt;=r[belong[x]];i++)&#123;//把整个块标记全部下放 w[i]=((w[i]*tag_mul[belong[x]]%mo)+tag_add[belong[x]])%mo; &#125; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) w[i]=(w[i]+v)%mo; tag_mul[belong[x]]=1; tag_add[belong[x]]=0; if(belong[x]!=belong[y])&#123; for(int i=l[belong[y]];i&lt;=r[belong[y]];i++)&#123; w[i]=((w[i]*tag_mul[belong[y]]%mo)+tag_add[belong[y]])%mo; &#125; for(int i=l[belong[y]];i&lt;=y;i++) w[i]=(w[i]+v)%mo; tag_mul[belong[y]]=1; tag_add[belong[y]]=0; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag_add[i]=(tag_add[i]+v)%mo;&#125;inline void mul(int x,int y,int v)&#123; for(int i=l[belong[x]];i&lt;=r[belong[x]];i++)&#123; w[i]=((w[i]*tag_mul[belong[x]]%mo)+tag_add[belong[x]])%mo; &#125; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) w[i]=w[i]*v%mo; tag_mul[belong[x]]=1; tag_add[belong[x]]=0; if(belong[x]!=belong[y])&#123; for(int i=l[belong[y]];i&lt;=r[belong[y]];i++)&#123; w[i]=((w[i]*tag_mul[belong[y]]%mo)+tag_add[belong[y]])%mo; &#125; for(int i=l[belong[y]];i&lt;=y;i++) w[i]=w[i]*v%mo; tag_mul[belong[y]]=1; tag_add[belong[y]]=0; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++)&#123; tag_add[i]=tag_add[i]*v%mo;//对加法标记也进行乘操作 tag_mul[i]=tag_mul[i]*v%mo; &#125;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(); for(int i=1;i&lt;=n;i++)&#123; int opt=read(),L=read(),R=read(),c=read(); if(opt==0) add(L,R,c); else if(opt==1) mul(L,R,c); else printf("%lld\n",((w[R]*tag_mul[belong[R]]%mo)+tag_add[belong[R]])%mo); &#125; return 0;&#125; LOJ数列分块8：给你一个序列，每次操作查询一段区间等于某个数$x$的数的个数，并把这段区间改成$x$。序列长度$&lt;=100000$ 做法和$hzwer$的不太一样。讲一下我的方法： 考虑和数列分块2一样的做法，如果一个块内是有序的，那么我们可以通过二分查找等于$c$的个数，具体怎么找呢？我们先用$lowerbound$，找到大于等于$c$的第一个数，如果这个数不等于$c$，或者这个块内最大数也没$c$大，显然这个区间没有等于$c$的数，否则我们设找到的左端点为$L$。如果这个区间有等于$c$的数，我们再$upperbound$，找到第一个大于$c$的位置，这个位置的左边一个位置，我们设为$R$，那么现在，$L$到$R$之间的数都等于$c$，$c$的个数就是$R-L+1$。 对于修改操作，我们仍旧采用边角块暴力修改，完整块打标记。这里的标记我们分两种，一种随便取个值，表示这个块内数值都不相同（我取了$-1e9$），另一种就表示这个块内数值都等于这个标记。 查询边角块注意事项：边角块暴力查询之前，要把整个块都变成标记表示的数值（如果有标记），暴力修改后，这个块标记赋值为$-1e9$，并对这个块排序。完整块就按之前讲的来。 和数列分块2一样，为了防止排序造成的位置变动，我们也用一个$t$数组记录没排序的数组来进行暴力操作。 分析一下复杂度，貌似是$O(n\ log \ n+n\times (\sqrt{n}+\sqrt{n}\ log \ \sqrt{n}))$（不知道对不对，我太菜不会分析复杂度）。显然需要卡常技巧，效率肯定没$hzwer$的做法高，我开$O2$才水过去的。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int n,size,num,w[100005],t[100005],belong[100005],l[10005],r[10005],tag[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void build()&#123; size=sqrt(n); num=n/size; if(n%size) num++; for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; tag[i]=-1e9; &#125; r[num]=n; for(int i=1;i&lt;=num;i++) sort(w+l[i],w+r[i]+1);&#125;inline int query(int x,int y,int c)&#123; int res=0; if(tag[belong[x]]!=-1e9) for(int i=l[belong[x]];i&lt;=r[belong[x]];i++) t[i]=tag[belong[x]]; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) if(t[i]==c) res++; if(belong[x]!=belong[y])&#123; if(tag[belong[y]]!=-1e9) for(int i=l[belong[y]];i&lt;=r[belong[y]];i++) t[i]=tag[belong[y]]; for(int i=l[belong[y]];i&lt;=y;i++) if(t[i]==c) res++; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++)&#123; if(tag[i]==-1e9)&#123; int pos1=lower_bound(w+l[i],w+r[i]+1,c)-w; if(pos1==r[i]+1) continue; if(w[pos1]!=c) continue; int pos2=upper_bound(w+l[i],w+r[i]+1,c)-w; res+=pos2-pos1; &#125; else if(tag[i]==c) res+=r[i]-l[i]+1; &#125; return res;&#125;inline void update(int x,int y,int c)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) t[i]=c; for(int i=l[belong[x]];i&lt;=r[belong[x]];i++) w[i]=t[i]; sort(w+l[belong[x]],w+r[belong[x]]+1); tag[belong[x]]=-1e9; if(belong[x]!=belong[y])&#123; for(int i=l[belong[y]];i&lt;=y;i++) t[i]=c; for(int i=l[belong[y]];i&lt;=r[belong[y]];i++) w[i]=t[i]; sort(w+l[belong[y]],w+r[belong[y]]+1); tag[belong[y]]=-1e9; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]=c;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(),t[i]=w[i]; build(); for(int i=1;i&lt;=n;i++)&#123; int L=read(),R=read(),c=read(); printf("%d\n",query(L,R,c)); update(L,R,c); &#125; return 0;&#125; LOJ数列分块9： 给你一个序列，每次操作查询一段区间的最小众数。序列长度$&lt;=100000$ 先给出我的$O(n \ log \ n+n\sqrt{n} \ log \ n)$的做法。(但是因为我菜常数实在太大了$LOJ$跑不过去) 显然先把数离散化，我用的$map$，复杂度$O(n\ log \ n)$，然后我们预处理出每两个块区间的众数，用桶暴力统计，复杂度$O(n\sqrt{n})$。对于每一个询问，因为中间完整块的众数我们已经统计出，所以我们只要判断边角块的数可不可能成为众数。 暴力判断每一个数，怎么统计$l$到$r$之间某个数出现了几次？我们初始化时将每一个数出现的位置用$vector$存下来，然后对于边角块的每一个数，在$vector$内二分查找$l$和$r$，两者相减即可。这样我们就判断了所有情况，边角块大小$O(\sqrt{n})$，查询复杂度每次$O(log \ n)$，询问个数$O(n)$，询问总复杂度$O(n\sqrt{n} \ log \ n)$。 常数极大的代码（调到自闭都没过）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#pragma GCC optimize(3)#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int belong[100005],a[100005],n,m,size,num,val[100005],id,maxx[505][505],tot[100005];int l[1005],r[1005],vis[100005];vector&lt;int&gt; v[100005];map&lt;int,int&gt; ma;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void init(int x)&#123;//预处理每两块之间的众数 int count=0,mx=0; for(int i=(x-1)*size+1;i&lt;=n;i++)&#123; tot[a[i]]++; if(tot[a[i]]&gt;count||(tot[a[i]]==count&amp;&amp;val[a[i]]&lt;val[mx]))&#123; count=tot[a[i]]; mx=a[i]; &#125; maxx[x][belong[i]]=mx; &#125; for(int i=(x-1)*size+1;i&lt;=n;i++) tot[a[i]]=0;&#125;inline int check(int l,int r,int c)&#123; return upper_bound(v[c].begin(),v[c].end(),r)-lower_bound(v[c].begin(),v[c].end(),l);&#125;inline int work(int x,int y)&#123; int ans=maxx[belong[x]+1][belong[y]-1],count=0,tt; vis[ans]=1; tt=ans; count=check(x,y,ans); for(int i=x;i&lt;=min(y,belong[x]*size);i++)&#123; if(!vis[a[i]])&#123; vis[a[i]]=1; int t=check(x,y,a[i]); if(t&gt;count||(t==count&amp;&amp;val[a[i]]&lt;val[ans]))&#123; ans=a[i]; count=t; &#125; &#125; &#125; if(belong[x]!=belong[y])&#123; for(int i=(belong[y]-1)*size+1;i&lt;=y;i++)&#123; if(!vis[a[i]])&#123; vis[a[i]]=1; int t=check(x,y,a[i]); if(t&gt;count||(t==count&amp;&amp;val[a[i]]&lt;val[ans]))&#123; count=t; ans=a[i]; &#125; &#125; &#125; for(int i=(belong[y]-1)*size+1;i&lt;=y;i++) vis[a[i]]=0; &#125; for(int i=x;i&lt;=min(y,belong[x]*size);i++) vis[a[i]]=0; vis[tt]=0; return val[ans];&#125;signed main()&#123; n=read(); size=sqrt(n); num=n/size; for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); belong[i]=(i-1)/size+1; if(ma[a[i]]==0)&#123; ma[a[i]]=++id; val[id]=a[i];//编号对应的值 &#125; a[i]=ma[a[i]];//离散化 v[a[i]].push_back(i); &#125; for(int i=1;i&lt;=num;i++) init(i); for(int i=1;i&lt;=n;i++)&#123; int x=read(),y=read(); printf("%d\n",work(x,y)); &#125; return 0;&#125; 没过啊怎么办？只能优化对不对。看着这只$log$我们感到它非常欠$A$，它让我们复杂度多了十几倍，那我们就把它$A$掉。要搞掉这只$log$，也就是说我们处理边角块的复杂度要到$O(\sqrt{n})$，不能对每个数都暴力处理，而是进行线性操作。 怎么操作呢？我们可以对当前的答案（即当前众数个数）进行判断，在预处理时我们记录每种颜色在同种颜色位置序列中是第几个，存在$pos$数组里，如果不懂的话可以看下代码。（因为是$vector$里所以下标从0开始）暴力处理边角块时，设我们在处理左边角块，设当前众数出现了$count$次，当前处理的数在整个序列中下标为$i$，则如果当前数$a[i]$是区间的众数，一定满足 $pos[i]+count-1&gt;=0$ $pos[i]+count-1&lt;v[a[i]].size()$ $v[a[i]][pos[i]+count-1]&gt;=x$ $v[a[i]][pos[i]+count-1]&lt;=y$ （$v$是存离散编号的数的位置的容器，$v[i]$存编号为$i$的数在序列中的位置，$x,y$是询问区间）。不是很容易理解，可以看代码理解一下。 如果这些条件都满足，判一下和当前$ans$的值，谁小就取谁。 处理右边角块时则是$pos[i]-count+1$。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define ll long long#define hh puts("")using namespace std;int belong[100005],a[100005],n,m,size,num,val[100005],id,maxx[505][505],f[505][505],tot[100005],pos[100005];int l[1005],r[1005];vector&lt;int&gt; v[100005];map&lt;int,int&gt; ma;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void init(int x)&#123;//预处理每两块之间的众数 int count=0,mx=0; for(int i=l[x];i&lt;=n;i++)&#123; tot[a[i]]++; if(tot[a[i]]&gt;count||(tot[a[i]]==count&amp;&amp;val[a[i]]&lt;val[mx]))&#123; count=tot[a[i]]; mx=a[i]; &#125; maxx[x][belong[i]]=mx;//哪一个众数 f[x][belong[i]]=count;//出现次数 &#125; for(int i=l[belong[x]];i&lt;=n;i++) tot[a[i]]=0;&#125;inline int work(int x,int y)&#123; int ans=maxx[belong[x]+1][belong[y]-1],count=f[belong[x]+1][belong[y]-1];//ans:哪一个众数,count:出现了几次 for(int i=x;i&lt;=min(y,r[belong[x]]);i++)&#123; if(pos[i]+count-1&gt;=0&amp;&amp;pos[i]+count-1&lt;(int)v[a[i]].size()&amp;&amp;v[a[i]][pos[i]+count-1]&gt;=x&amp;&amp;v[a[i]][pos[i]+count-1]&lt;=y) if(val[a[i]]&lt;val[ans]) ans=a[i]; for(;pos[i]+count&lt;(int)v[a[i]].size()&amp;&amp;v[a[i]][pos[i]+count]&lt;=y;++count) ans=a[i]; &#125; if(belong[x]!=belong[y])&#123; for(int i=l[belong[y]];i&lt;=y;i++)&#123; if(pos[i]-count+1&gt;=0&amp;&amp;pos[i]-count+1&lt;(int)v[a[i]].size()&amp;&amp;v[a[i]][pos[i]-count+1]&gt;=x&amp;&amp;v[a[i]][pos[i]-count+1]&lt;=y) if(val[a[i]]&lt;val[ans]) ans=a[i]; for(;pos[i]-count&gt;=0&amp;&amp;v[a[i]][pos[i]-count]&gt;=x;++count) ans=a[i]; &#125; &#125; return val[ans];&#125;inline void write(int x)&#123; if(x&gt;9) write(x/10); putchar(x%10+48);&#125;signed main()&#123; n=read(); size=sqrt(n); num=n/size; if(n%size) num++; for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); belong[i]=(i-1)/size+1; if(ma[a[i]]==0)&#123; ma[a[i]]=++id; val[id]=a[i];//编号对应的值 &#125; a[i]=ma[a[i]];//离散化 pos[i]=v[a[i]].size(); v[a[i]].push_back(i); &#125; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n; for(int i=1;i&lt;=num;i++) init(i); for(int i=1;i&lt;=n;i++)&#123; int x=read(),y=read(); write(work(x,y)); hh; &#125; return 0;&#125; 总之最后一题是最难的，可能分析的并不是很好。 至此我们做完了$LOJ$数列分块9题，完结撒花~。 $hzwer$的题还是挺不错的，做完后对分块的基本认识肯定更深一点，对分块的基本代码也巩固了，之后的话$\cdots$ 听说$ynoi$的题很有意思，去玩一玩（被毒死）？]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>分块</tag>
      </tags>
  </entry>
</search>
