<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 luoguP3320 【[SDOI2015]寻宝游戏】]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%A2%98%E8%A7%A3%20luoguP3320%20%E3%80%90%5BSDOI2015%5D%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到建虚树的做法？？？不会 这题要求每一次加减操作都计算答案，那么我们考虑加入一个点的贡献。 慢慢分析：首先一个点或者没有点，肯定没有贡献，为0。 然后是两个点，随便从一个点开始，走到另一个点再返回，贡献为2 $\times$ $dis(x,y)$。 回忆一下树上两点距离：$x$到$y$的距离$=$ $x$到根的距离$+$ $y$到根的距离$-$ $lca(x,y)$到根的距离$\times$ 2。($lca$想怎么求怎么求) 再增加一个点呢？树上有3个点，怎么走能使距离最短？应该是按遍历时的时间戳走咯。假设时间戳为1，2，3，那么贡献就是1-&gt;2 $+$ 2-&gt;3 $+$ 3-&gt;1。(箭头表示两点之间距离) 那么不管几个点，我们发现按时间戳走肯定最快。所以考虑维护加入点的时间戳。蒟蒻我不会$splay$，只能甩出一手$STL$大法$set$。(STL大法好) 每插入一个元素，考虑增加的贡献，是先删去它时间戳($set$里面)左边和右边的贡献，再加上它和左边以及它和右边的贡献。删去一个元素同理。这题做完，对$set$的使用以后就会很熟练了。 注意特判一个点的情况以及开$long long$。 上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define ite set&lt;int&gt;::iterator#define ls(x) (x&lt;&lt;1)#define rs(x) (x&lt;&lt;1|1)#define hh puts("")using namespace std;int n,m,cnt,head[100005],dfn[100005],bz[100005][20],dis[100005],vis[100005],dep[100005],ans;set&lt;int&gt; s;struct Edge&#123; int v,nx,s;&#125;e[200005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].nx=head[x]; e[cnt].s=z; head[x]=cnt;&#125;void dfs(int now,int fa)&#123; dfn[now]=++cnt;//时间戳 vis[cnt]=now;//dfs序 dep[now]=dep[fa]+1; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(v==fa) continue; dis[v]=dis[now]+e[i].s; bz[v][0]=now; dfs(v,now); &#125;&#125;inline ite lef(ite it)&#123; if(it==s.begin()) return --s.end(); return --it;&#125;inline ite rig(ite it)&#123; if(it==--s.end()) return s.begin(); return ++it;&#125;inline int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=17;i&gt;=0;i--)&#123; if(dep[bz[x][i]]&gt;=dep[y]) x=bz[x][i]; &#125; if(x==y) return x; for(int i=17;i&gt;=0;i--) if(bz[x][i]!=bz[y][i]) x=bz[x][i],y=bz[y][i]; return bz[x][0];&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;i++)&#123; int x=read(),y=read(),z=read(); add(x,y,z); add(y,x,z); &#125; cnt=0; dis[1]=0; dfs(1,0); for(int k=1;k&lt;=17;k++) for(int i=1;i&lt;=n;i++) bz[i][k]=bz[bz[i][k-1]][k-1]; for(int i=1;i&lt;=m;i++)&#123; int x=read(); if(!s.count(dfn[x]))&#123; if(s.size())&#123; ite it=s.lower_bound(dfn[x]); if(it==s.end()) it=s.begin(); ite L=lef(it); int lca1=LCA(vis[*it],vis[*L]); int lca2=LCA(vis[*it],x); int lca3=LCA(vis[*L],x); ans-=dis[vis[*it]]+dis[vis[*L]]-2*dis[lca1]; ans+=dis[vis[*it]]+dis[x]-2*dis[lca2]; ans+=dis[vis[*L]]+dis[x]-2*dis[lca3]; &#125; s.insert(dfn[x]); printf("%lld\n",ans); continue; &#125; else&#123; ite it=s.find(dfn[x]); ite L=lef(it),R=rig(it); int lca1=LCA(x,vis[*L]); int lca2=LCA(x,vis[*R]); int lca3=LCA(vis[*L],vis[*R]); ans-=dis[x]+dis[vis[*L]]-2*dis[lca1]; ans-=dis[x]+dis[vis[*R]]-2*dis[lca2]; ans+=dis[vis[*L]]+dis[vis[*R]]-2*dis[lca3]; s.erase(dfn[x]); printf("%lld\n",ans); continue; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>LCA</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.2模拟赛T2]]></title>
    <url>%2F2019%2F03%2F13%2F2019.3.2%E6%A8%A1%E6%8B%9F%E8%B5%9BT2%2F</url>
    <content type="text"><![CDATA[题目地址 这是一道经典套路题。 ——讲课人同余最短路，第一次听说这种东西嘤嘤嘤，墨墨的等式那题也是一样 我学过语文！（丢人）题意一看就是让你求一个数能不能被若干个给你的数组合出来，考虑背包 我会背包！完全背包裸题啊是不是？ 我靠怎么询问这么大，背包它死了 我会套路！终于步入正轨 首先可以发现一个很简单的套路推论：取$a[i]$ $(1&lt;=i&lt;=n)$中的最小值为$mn$，如果$x$可以被构造出来，那么$x$ $+$ $mn$ $\times$ $k$也可以被构造出来。（正确性显然） 我们定义一个$dis[x]$ ($0$ $&lt;=$ $x$ $&lt;$ $mn$)为最小的能构造出的$x$ $+$ $mn$ $\times$ $k$ ($k&gt;=0$ 且 $k$为整数) 那么对于任何一个数$t$，只要$t$大于等于$dis[t$ $\%$ $mn]$，那么显然$t$可以被构造$($需要意会$)$ 然后我们的问题就是如何求$dis$数组了，哈哈哈名字都叫$dis$那肯定是最短路了 数据这么小那直接$SPFA$乱搞咯$($这种题卡不了$SPFA$的$)$ 首先$dis[0]=0$，即构造$0$不需要选任何东西，然后每次从队列中取出一个去松弛其他点。设当前取出的为$x$，枚举每个$a[i]$去松弛$dis[(x+a[i])$ $\%$ $mn]$，其他都是常规写法 至此我们解决完了，上代码：$($超级短好不好$)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ll long long#define soo (1e9)#define oo (1e18)using namespace std;int n,a[5005],m,mo,vis[50005],dis[50005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void spfa()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q; dis[0]=0; q.push(0); while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=0;i&lt;n;i++)&#123; if(dis[(x+a[i])%mo]&gt;dis[x]+a[i])&#123; dis[(x+a[i])%mo]=dis[x]+a[i]; if(!vis[(x+a[i])%mo])&#123; vis[(x+a[i])%mo]=1; q.push((x+a[i])%mo); &#125; &#125; &#125; &#125;&#125;signed main()&#123; n=read(); for(int i=0;i&lt;n;i++) a[i]=read(); sort(a,a+n); mo=a[0]; spfa(); m=read(); for(int i=1;i&lt;=m;i++)&#123; int qu=read(); if(qu&lt;dis[qu%mo]) puts("NIE"); else puts("TAK"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>模拟赛</tag>
        <tag>最短路</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块学习笔记]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[看到$cr$奆佬一天就学会了分块，甚至看着题解$A$掉了$YNOI$的毒瘤分块题，我也来入坑了哈哈哈哈哈。$($本文总结了巨多别人的博客$)$ 分块是一个很暴力的算法！咳咳先不提这个。。。 啥是分块：分块是一个很暴力的算法。分块将所有数据分为若干个块，维护块内信息，使得块内的查询是$O(1)$的，而总的询问就可以看做若干个块询问的总和。一般来讲，块的大小常设为$sqrt(n)$，但实际上块的大小可以任意自定，通过调试来尽可能让复杂度更优。 偷图： 为什么要分块：因为。。。分块是一个很暴力的算法。它可以完成几乎所有区间更新和区间查询问题$($考场骗分利器$)$。对于小数据，可能效率与线段树相似。虽然大数据可能效率较低，但有些题的确只能用分块做$($神仙不管$)$。总之，分块的适用性比线段树要广，毕竟是暴力算法 分块实现的基本框架： 划分块，预处理，操作或查询。 操作或查询通常为4步：1.判断要操作或是查询的区间是否在一个块内 2.若在一个块内，暴力操作或查询 3.若不在一个块内，将除了最左边和最右边这两个块外其余的块进行整体的操作，即直接对块打上修改标记之类的 4.单独暴力处理最左边的块和最右边的块 分块的基础即建块，类比线段树建树。用$size$表示每一块的大小，$num$表示一共几块，$belong[i]$表示原序列中第$i$个元素在第几块，$l[i],r[i]$分别表示第$i$块的左端点和右端点。上代码：1234567891011void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++;//除不尽说明多出一块边角料 for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n;//最后一块大小可能不为size,右边界特殊处理 &#125; 来一道基础题：给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，单点查值。$(1\leq n\leq 50000)$ 链接 这种题当然可以各种姿势水过去，但我们要学习分块，所以就分块咯。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int n,size,num,belong[100005],l[10005],r[10005],tag[10005],w[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++; for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n; &#125;void add(int x,int y,int v)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) w[i]+=v;//左边边角块 if(belong[x]!=belong[y])&#123;//不在同一个块 for(int i=(belong[y]-1)*size+1;i&lt;=y;i++)//右边边角块 w[i]+=v; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]+=v;//块整体打标记&#125;int query(int x)&#123; return w[x]+tag[belong[x]];&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(); for(int i=1;i&lt;=n;i++)&#123; int opt=read(),x=read(),y=read(),v=read(); if(opt==0) add(x,y,v); else printf("%d\n",query(y)); &#125; return 0;&#125; 分块也可以水数据小的线段树，rt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n,m,size,num,belong[100005],l[10005],r[10005],sum[10005],tag[10005],w[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++;//除不尽说明多出一块边角料 for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n;//最后一块大小可能不为size,右边界特殊处理 &#125;void add(int x,int y,int v)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) w[i]+=v;//左边边角块 sum[belong[x]]+=(min(y,r[belong[x]])-x+1)*v; if(belong[x]!=belong[y])&#123;//不在同一个块 for(int i=(belong[y]-1)*size+1;i&lt;=y;i++) w[i]+=v; sum[belong[y]]+=(y-((belong[y]-1)*size+1)+1)*v; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]+=v,sum[i]+=v*size;&#125;int query(int x,int y)&#123; int res=0; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) res+=w[i]+tag[belong[x]]; if(belong[x]!=belong[y])&#123; for(int i=(belong[y]-1)*size+1;i&lt;=y;i++) res+=w[i]+tag[belong[y]]; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) res+=sum[i]; return res;&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(); for(int i=1;i&lt;=n;i++) sum[belong[i]]+=w[i]; for(int i=1;i&lt;=m;i++)&#123; int opt=read(),x=read(),y=read(); if(opt==1)&#123; int v=read(); add(x,y,v); &#125; else printf("%d\n",query(x,y)); &#125; return 0;&#125; 持续更新ing]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP1772 【[ZJOI2006]物流运输】]]></title>
    <url>%2F2019%2F03%2F13%2F%E9%A2%98%E8%A7%A3%20luoguP1772%20%E3%80%90%5BZJOI2006%5D%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[模拟赛居然考了这道题，前一天刚看过，结果看了舍不得(不会)做，结果只骗到30pt 讲课人：很容易想到最短路+$dp$(我靠一点都不容易) 模拟赛后分析，才知道是处理出第i天到第j天都走同一条最短路的花费为$co[i][j]$ 然后进行$dp$，$dp[i]$表示前i天的最小花费 转移方程很好想:$dp[i]$ $=$ $min$ $($ $dp[j]$ $+$ $co[j+1][i]$ $\times$ $(i-j)$ $+$ $k$ $)$，预处理要赋值为$co[1][i]$ $\times$ $i$ $dp$方程的意思，即在第$j+1$天改变路线，第$j+1$天~第$i$天都走同一条路线 那么如何处理$co[i][j]$? 很简单，对于每一个$(i,j)$，先把$i$到$j$天之间封闭的码头全部设为不可走，跑一遍最短路即可，初值为无穷 数据辣么小，跑几遍以及跑什么都没关系嘤嘤嘤 那我们就十分愉♂快的解决了此题~~~ 愉♂快的提交了然后居然只有90pt 原谅我无耻的打开题解 啊啊啊原来要开$long$ $long$(明明数据辣么小) 献上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define soo (1e8)#define ll long longusing namespace std;int d,cnt,head[25],dis[25],vis[25],cant_vis[25];ll co[105][105],dp[105];int n,m,k,ee,cl[25][105];struct Edge&#123; int v,nx,s;&#125;e[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].s=z; e[cnt].nx=head[x]; head[x]=cnt;&#125;void spfa()&#123;//爱跑什么跑什么 for(int i=1;i&lt;=m;i++) dis[i]=soo,vis[i]=0; queue&lt;int&gt; q; dis[1]=0; q.push(1); while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];i;i=e[i].nx)&#123; int v=e[i].v; if(cant_vis[v]) continue; if(dis[v]&gt;dis[x]+e[i].s)&#123; dis[v]=dis[x]+e[i].s; if(!vis[v])&#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125;&#125;signed main()&#123; n=read(),m=read(),k=read(),ee=read(); for(int i=1;i&lt;=ee;i++)&#123; int x=read(),y=read(),z=read(); add(x,y,z); add(y,x,z); &#125; d=read(); for(int i=1;i&lt;=d;i++)&#123; int t=read(),x=read(),y=read(); for(int j=x;j&lt;=y;j++) cl[t][j]=1; &#125; //cl[i][j]表示第i个码头在第j天不能走 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; memset(cant_vis,0,sizeof(cant_vis)); for(int r=i;r&lt;=j;r++) for(int l=1;l&lt;=m;l++) if(cl[l][r]) cant_vis[l]=1; spfa(); co[i][j]=dis[m]; &#125; memset(dp,0x7f,sizeof(dp)); for(int i=1;i&lt;=n;i++)&#123; dp[i]=(ll)co[1][i]*i; for(int j=i-1;j&gt;=0;j--) dp[i]=min(dp[i],dp[j]+co[j+1][i]*(i-j)+k); &#125; printf("%lld",dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2161 【[SHOI2009]会场预约】]]></title>
    <url>%2F2019%2F03%2F13%2F%E9%A2%98%E8%A7%A3%20luoguP2161%20%E3%80%90%5BSHOI2009%5D%E4%BC%9A%E5%9C%BA%E9%A2%84%E7%BA%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[线段树好题 。转换题意。将操作看成染色：操作$A$，即统计一段区间内颜色的种类数，并将这个区间修改为同一个颜色。操作$B$，统计整颗线段树上还剩下多少种颜色。 考虑如何用线段树实现这一操作：对于操作$A$，明显就是一个查询$-&gt;$覆盖的操作。对于查询，考虑在修改时进行查询。我们用一个$col[k]$数组维护一段区间的颜色是否为同一个。若为同一个，我们覆盖掉，并使$delans$++$(delans$表示拒绝掉的预约数$)$，否则，分左右两段递归修改。答案即$delans$。 这时有一个问题：若一种颜色一段在修改的区间内，一段在修改的区间外，怎么处理？根据题意要求：对于新的预约操作，只要与先前预约有冲突，就全部拒绝掉。那就再设计一个$del$数组，记录一种颜色是否被删掉，就可以做到只要一种颜色有一段在区间内，就能保证它被全部删掉。 操作$B$相对简单很多，维护一个全局颜色数$ans$，每次$A$操作染色，显然先使$ans$++$($多一种颜色$)$，在染色时，每拒绝掉一个预约，$ans$- -即可。然后操作$B$就要求输出$ans$。 完结撒花~~ 哦对，线段树标配$tag$数组就代表该区间的颜色，$tag$为$0$时表示没有颜色，无需下传。下传时的细节：既然下传了，那么显然区间不是同色，$col[k]$赋为$0$。显然原因：下传操作的进行，是因为当前区间不完全在修改区间范围内$($否则就直接$change$并且$return$了$)$，那么当前区间一部分在修改区间范围内，一部分不在，显然不同色。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define ll long long#define LL unsigned long long#define ls(x) x&lt;&lt;1#define rs(x) x&lt;&lt;1|1#define hh puts("")using namespace std;int n,col[400005],maxx,cnt,ans,del_cnt=0;int del[400005],tag[400005];struct Q&#123; int l,r,opt;&#125;q[200005];void build(int l,int r,int k)&#123; col[k]=1;//col[k]表示线段树中的k区间颜色都相同(把预约看成染色) if(l==r) return; int mid=(l+r)&gt;&gt;1; build(l,mid,ls(k)); build(mid+1,r,rs(k));&#125;void push_down(int l,int r,int k)&#123; col[k]=0; if(!tag[k]) return; tag[ls(k)]=tag[k]; tag[rs(k)]=tag[k]; tag[k]=0;&#125;void change(int l,int r,int v,int k)&#123; if(col[k])&#123; if(tag[k]&amp;&amp;!del[tag[k]])&#123; del_cnt++; ans--; &#125; del[tag[k]]=1; tag[k]=v; return; &#125; int mid=(l+r)&gt;&gt;1; change(l,mid,v,ls(k)); change(mid+1,r,v,rs(k)); col[k]=1,tag[k]=v;&#125;void update(int l,int r,int x,int y,int v,int k)&#123;//将x~y区间内所有颜色都变成v if(x&lt;=l&amp;&amp;r&lt;=y)&#123; change(l,r,v,k); return; &#125; push_down(l,r,k); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,x,y,v,ls(k)); if(mid+1&lt;=y) update(mid+1,r,x,y,v,rs(k));&#125;signed main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; char rd[5]; scanf("%s",rd+1); if(rd[1]=='A')&#123; q[i].opt=1; scanf("%d%d",&amp;q[i].l,&amp;q[i].r); maxx=max(maxx,q[i].r); &#125; else q[i].opt=2; &#125; build(1,maxx,1); for(int i=1;i&lt;=n;i++)&#123; if(q[i].opt==1)&#123; ans++; del_cnt=0; update(1,maxx,q[i].l,q[i].r,++cnt,1); printf("%d\n",del_cnt); &#125; else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF773D 【Perishable Roads】]]></title>
    <url>%2F2019%2F03%2F13%2F%E9%A2%98%E8%A7%A3%20CF773D%20%E3%80%90Perishable%20Roads%E3%80%91%2F</url>
    <content type="text"><![CDATA[简述一下题意：给出$n$个点的完全图，对于完全图中的每个点$i$，$i$作为终点时，要使其他每个点到点$i$的“距离”和最小，对于每个点都输出这个最小值。这里的“距离”是指对于其他每个点，那个点到点$i$路径上的最小值。且对于每个点$i$，计算答案时应保证图内每条边的方向一定。（有点难解释，可以参考原文） 题意很难表述清楚，建议看懂原题后再来看此题解。 考虑对于每个终点$i$，最后连接所有点后图的形态，应该是一棵树接上一条链。如图： 我会贪心&amp;&amp;搜索！从终点开始倒搜，对于当前搜到的点$now$，每次找到未$vis$的且与$now$相连的边权最小的点，向那个点继续搜。 很显然这个想法是非常非常错误的，直接排除 考虑优化贪心：既然让每个点到终点路径上的最小边权和最小，那么很容易想到将所有点都连到边权最小的边的一端，再从这个点连向终点。$($下文我们将这个点称为“最小点”$)$ 但这个还是错误的，如果连向终点的那条边权值特别大$(INF)$，那么答案就会非常劣。如图： 那怎么办呢？我们就考虑让“最小点”去间接的连向终点，即从那些直接连向“最小点”的点中取一些出来，与“最小点”构成一条链，使这一条链加上那棵树的答案更优。我们称这条链$($起点为最小点,终点为$t$ $)$的答案为$dis[t]$。如图： 怎么计算答案呢？我们设那条链上除终点外有$x$个点，那么那棵树上就有$n-1-x$个点，设最小边长度为$minn$，那么答案为$dis[t]$+$minn$ $\times$ $(n-1-x)$。 这个$x$很难计算，考虑消去。即计算$dis[t]$前先对所有边权减去一个$minn$，设新链答案为$dis’[t]$，那么答案会变成$($ $dis’[t]$+$minn$ $\times$ $x$ $)$+$minn$ $\times$ $(n-1-x)$，即$dis’[t]$+$minn$ $\times$ $(n-1)$，$x$就消去了。所以我们计算$dis’[t]$即可。 因为要求最优解，我们跑最短路求$dis$ $($定义见上$)$。一开始的状态是上面图2，即向终点直接连边，所以赋为终点与最小点的边权$($详见代码$)$。还有一种状态，即考虑那条链上有3个点。设加入的为点$j$，那么链的答案可能为最小点到终点的答案加上$j$到终点的答案，即$f[i][j]*2$ $($ $f$数组为邻接矩阵，$i$是终点 $)$。最后$dij$松弛即可$($模板$)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int n,f[3005][3005],vis[3005],dis[3005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void write(int x)&#123; if(x&lt;0)&#123;putchar('-');x=-x;&#125; if(x&gt;9)write(x/10); putchar(x%10+48);&#125;void dij(int st)&#123; for(int i=1;i&lt;=n;i++)&#123; dis[i]=f[st][i]; for(int j=1;j&lt;=n;j++) if(i!=j) dis[i]=min(dis[i],f[i][j]*2); &#125; vis[st]=1; for(int i=1;i&lt;=n-1;i++)&#123; int minn=2e9+1,k; for(int j=1;j&lt;=n;j++) if(!vis[j]&amp;&amp;dis[j]&lt;minn)&#123; minn=dis[j]; k=j; &#125; vis[k]=1; for(int j=1;j&lt;=n;j++) if(!vis[j]) dis[j]=min(dis[j],dis[k]+f[j][k]); &#125;&#125;int main()&#123; int minn=2e9+1,k; n=read(); for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=n-i;j++)&#123; f[i][i+j]=f[i+j][i]=read(); if(f[i][i+j]&lt;minn)&#123; minn=f[i][i+j]; k=i; &#125; &#125; for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=n-i;j++)&#123; f[i][i+j]-=minn; f[i+j][i]=f[i][i+j]; &#125; dij(k); for(int i=1;i&lt;=n;i++) printf("%d ",dis[i]+minn*(n-1)); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛学习笔记]]></title>
    <url>%2F2019%2F03%2F12%2F%E7%BA%BF%E6%80%A7%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[看了一大堆令人自闭的证明，还是写写自己愚蠢的理解吧 1234567for(int i=2;i&lt;=n;i++)&#123; if(v[i]) pr[++top]=i; for(int j=1;j&lt;=top&amp;&amp;pr[j]*i&lt;=n;j++)&#123; v[pr[j]*i]=0; if(i%pr[j]==0) break; &#125;&#125; 模板代码。线性筛的本质，也就是保证一个数只会被它的最小质因子$*$最大因数所筛去。那句$if$ $($i $\%$ $pr[j]==0$ $)$ $break;$ 什么意思呢？ 我所理解，就是如果$i$ $\%$ $pr[j]==0$，那么$i$就可以写成$pr[j]*x$。 $x$可能比$pr[j]$要小，那么$pr[j]$就不是所筛的下一个合数的最小质因子，也就是说会被重复筛去。 举个栗子：$i=6$，若$pr[j]=2$时没有$break$，那么$pr[j]=3$时会筛去$18$，然而$18$还会在$i=9$时被$9*2$筛去，就重复筛了。 所以说，这句话很重要$($这不是废话吗$)$。]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>素数</tag>
      </tags>
  </entry>
</search>
