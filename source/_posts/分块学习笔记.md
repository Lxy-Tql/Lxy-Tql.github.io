---
title: 分块学习笔记
date: 2019-02-17 21:07:56
top: 2
tag: 
- 学习笔记
- 分块
---
## 分块学习笔记及入门题选讲

#### 分块是一个很暴力的算法！
咳咳先不提这个。。。

啥是分块：~~分块是一个很暴力的算法~~。分块将所有数据分为若干个块，维护块内信息，使得块内的查询是$O(1)$的，而总的询问就可以看做若干个块询问的总和。一般来讲，块的大小常设为$sqrt(n)$，但实际上块的大小可以任意自定，通过调试来尽可能让复杂度更优。

图：![](https://s2.ax1x.com/2019/05/02/ENpT4x.png)

为什么要分块：因为。。~~分块是一个很暴力的算法~~。它可以完成几乎所有区间更新和区间查询问题$($考场骗分利器$)$。对于小数据，可能效率与线段树相似。虽然大数据可能效率较低，但有些题的确只能用分块做$($~~神仙不管~~$)$。总之，分块的适用性比线段树要广，毕竟是暴力算法

分块实现的基本框架：
划分块，预处理，操作或查询。

操作或查询通常为4步：
1.判断要操作或是查询的区间是否在一个块内

2.若在一个块内，暴力操作或查询

3.若不在一个块内，将除了最左边和最右边这两个块外其余的块进行整体的操作，即直接对块打上修改标记之类的

4.单独暴力处理最左边的块和最右边的块

分块的基础即建块，类比线段树建树。用$size$表示每一块的大小，$num$表示一共几块，$belong[i]$表示原序列中第$i$个元素在第几块，$l[i],r[i]$分别表示第$i$块的左端点和右端点。
上代码：
```cpp
void build(){
    size=sqrt(n);
    num=n/size;
    if(n%size!=0) num++;//除不尽说明多出一块边角料
    for(int i=1;i<=n;i++) belong[i]=(i-1)/size+1; 
    for(int i=1;i<=num;i++){
        l[i]=(i-1)*size+1;
        r[i]=i*size;
    }
    r[num]=n;//最后一块大小可能不为size,右边界特殊处理 
}
```
来一道基础题：给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，单点查值。$(1\leq n\leq 50000)$ [LOJ数列分块1](https://loj.ac/problem/6277)

这种题当然可以各种姿势水过去，但我们要学习分块，所以就分块咯。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,size,num,belong[100005],l[10005],r[10005],tag[10005],w[100005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
    return ret*ff;
}
void build(){
    size=sqrt(n);
    num=n/size;
    if(n%size!=0) num++;
    for(int i=1;i<=n;i++) belong[i]=(i-1)/size+1; 
    for(int i=1;i<=num;i++){
        l[i]=(i-1)*size+1;
        r[i]=i*size;
    }
    r[num]=n; 
}
void add(int x,int y,int v){
    for(int i=x;i<=min(y,r[belong[x]]);i++) w[i]+=v;//左边边角块 
    if(belong[x]!=belong[y]){//不在同一个块 
        for(int i=(belong[y]-1)*size+1;i<=y;i++)//右边边角块 
            w[i]+=v;
    }
    for(int i=belong[x]+1;i<=belong[y]-1;i++) tag[i]+=v;//块整体打标记
}
int query(int x){
    return w[x]+tag[belong[x]];
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++) w[i]=read();
    build();
    for(int i=1;i<=n;i++){
        int opt=read(),x=read(),y=read(),v=read();
        if(opt==0) add(x,y,v);
        else printf("%d\n",query(y));
    }
    return 0;
}
```
分块也可以水数据小的线段树，[LOJ数列分块4](https://loj.ac/problem/6280)
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,size,num,belong[100005],l[10005],r[10005],sum[10005],tag[10005],w[100005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
    return ret*ff;
}
void build(){
    size=sqrt(n);
    num=n/size;
    if(n%size!=0) num++;
    for(int i=1;i<=n;i++) belong[i]=(i-1)/size+1; 
    for(int i=1;i<=num;i++){
        l[i]=(i-1)*size+1;
        r[i]=i*size;
    }
    r[num]=n;
}
void add(int x,int y,int v){
    for(int i=x;i<=min(y,r[belong[x]]);i++) w[i]+=v;//左边边角块
    sum[belong[x]]+=(min(y,r[belong[x]])-x+1)*v;
    if(belong[x]!=belong[y]){//不在同一个块 
        for(int i=(belong[y]-1)*size+1;i<=y;i++) w[i]+=v;
        sum[belong[y]]+=(y-((belong[y]-1)*size+1)+1)*v;
    }
    for(int i=belong[x]+1;i<=belong[y]-1;i++) tag[i]+=v,sum[i]+=v*size;
}
int query(int x,int y){
    int res=0;
    for(int i=x;i<=min(y,r[belong[x]]);i++) res+=w[i]+tag[belong[x]];
    if(belong[x]!=belong[y]){ 
        for(int i=(belong[y]-1)*size+1;i<=y;i++) 
            res+=w[i]+tag[belong[y]];
    }
    for(int i=belong[x]+1;i<=belong[y]-1;i++) res+=sum[i];
    return res;
}
signed main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++) w[i]=read();
    build();
    for(int i=1;i<=n;i++) sum[belong[i]]+=w[i];
    for(int i=1;i<=m;i++){
        int opt=read(),x=read(),y=read();
        if(opt==1){
            int v=read();
            add(x,y,v);
        }
        else printf("%d\n",query(x,y));
    }
    return 0;
}
```

~~分块咕了好久了，今天应该会更吧(确信~~

[LOJ数列分块2](https://loj.ac/problem/6278)：

给你一个序列，要求资瓷区间加，以及区间查询小于某个数的元素个数。序列长度$<=50000$

分块怎么考虑？要查询小于某个数的个数，我们可以一个块一个块查，最后把答案合并起来。

那么一个块内怎么查小于某个数的元素个数呢？显然在块内二分，查到第一个大于等于这个数的位置，这个位置的左边一个位置到这个块的左边界就是这个块的答案。二分需要满足单调性，那我们就时刻维护块内元素有序即可。

已经解决了查询的问题，修改还不方便？用分块的基本套路：左右边角块暴力加，中间完整块打标记。我们发现中间完整块整体加一个数，仍旧保持有序，左右暴力加后变成无序，所以加完要再排一遍序。

照着这个思路写完，爆弹了，反复检查没有看出锅，不知道错在哪里。突然发现一个问题：如果我们只用一个数组，排完序后会打乱原有顺序，导致我们想加的数的位置不在原来位置上。

放张图理解一下：
![](https://s2.ax1x.com/2019/05/07/ErYLT0.png)

假如这是原来的每个位置上的值（红线代表划分的块），排过序后，变成这样：
![](https://s2.ax1x.com/2019/05/07/ErtshT.png)

这时我们想在位置3上加上一个数（注意是位置），比如加2。按照之前的思路，我们会在当前的位置（第二张图）3上加2，也就是给3加上2，则第一个块变成1,2,5。但实际上，我们应该在第一张图的位置3上加2，第一个块应该是2,3,3，那怎么处理这种情况？也很简单，保留一下原序列，排序在另一个数组上排序，而操作在原序列上操作（原序列不排序）。这样就不会有加错位置的问题了。可以见代码（原序列是t，用来排序的是w）：

```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
using namespace std;
int n,w[50005],belong[50005],sz[10005],t[50005],num,size,tag[10005],l[10005],r[10005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline void build(){
    size=sqrt(n*1.0);
    num=n/size;
    if(n%size) num++;
    for(int i=1;i<=n;i++) belong[i]=(i-1)/size+1;
    for(int i=1;i<=num;i++){
        l[i]=(i-1)*size+1;
        r[i]=i*size;
    }
    r[num]=n;
    for(int i=1;i<=num;i++) sort(w+l[i],w+r[i]+1);
}
inline void add(int x,int y,int v){
    for(int i=x;i<=min(y,r[belong[x]]);i++) t[i]+=v;//在原序列上加
    for(int i=l[belong[x]];i<=r[belong[x]];i++) w[i]=t[i];
    sort(w+l[belong[x]],w+r[belong[x]]+1);
    if(belong[x]!=belong[y]){
        for(int i=l[belong[y]];i<=y;i++) t[i]+=v;
        for(int i=l[belong[y]];i<=r[belong[y]];i++) w[i]=t[i];
        sort(w+l[belong[y]],w+r[belong[y]]+1);
    }
    for(int i=belong[x]+1;i<=belong[y]-1;i++) tag[i]+=v;
}
inline int query(int x,int y,int v){
    int res=0,pos;
    for(int i=x;i<=min(y,r[belong[x]]);i++){
        if(t[i]+tag[belong[x]]<v)//对原序列查询
            res++;
    }
    if(belong[x]!=belong[y]){
        for(int i=l[belong[y]];i<=y;i++)
            if(t[i]+tag[belong[y]]<v)
                res++;
    }
    for(int i=belong[x]+1;i<=belong[y]-1;i++){
        pos=lower_bound(w+l[i],w+r[i]+1,v-tag[i])-w;
        pos--;//二分找到的是第一个大于等于的，左边一位就是小于的
        res+=pos-l[i]+1;
    }
    return res;
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++) w[i]=read(),t[i]=w[i];
    build();
    for(int i=1;i<=n;i++){
        int opt=read(),L=read(),R=read(),c=read();
        if(opt==0) add(L,R,c);
        else printf("%lld\n",query(L,R,c*c));
    }
    return 0;
}
```

[LOJ数列分块3](https://loj.ac/problem/6279)：

给你一个序列，要求资瓷区间加，以及区间查询小于某个数的最大的数。序列长度$<=100000$

做完2再做3发现是一样的题，查询时改为取$max$即可：

代码几乎和2一样：
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
using namespace std;
int n,w[100005],belong[100005],sz[10005],t[100005],num,size,tag[10005],l[10005],r[10005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline void build(){
    size=sqrt(n*1.0);
    num=n/size;
    if(n%size) num++;
    for(int i=1;i<=n;i++) belong[i]=(i-1)/size+1;
    for(int i=1;i<=num;i++){
        l[i]=(i-1)*size+1;
        r[i]=i*size;
    }
    r[num]=n;
    for(int i=1;i<=num;i++) sort(w+l[i],w+r[i]+1);
}
inline void add(int x,int y,int v){
    for(int i=x;i<=min(y,r[belong[x]]);i++) t[i]+=v;
    for(int i=l[belong[x]];i<=r[belong[x]];i++) w[i]=t[i];
    sort(w+l[belong[x]],w+r[belong[x]]+1);
    if(belong[x]!=belong[y]){
        for(int i=l[belong[y]];i<=y;i++) t[i]+=v;
        for(int i=l[belong[y]];i<=r[belong[y]];i++) w[i]=t[i];
        sort(w+l[belong[y]],w+r[belong[y]]+1);
    }
    for(int i=belong[x]+1;i<=belong[y]-1;i++) tag[i]+=v;
}
inline int query(int x,int y,int v){
    int res=-1e15,pos;
    for(int i=x;i<=min(y,r[belong[x]]);i++){
        if(t[i]+tag[belong[x]]<v)
            res=max(res,t[i]+tag[belong[x]]);
    }
    if(belong[x]!=belong[y]){
        for(int i=l[belong[y]];i<=y;i++)
            if(t[i]+tag[belong[y]]<v)
                res=max(res,t[i]+tag[belong[y]]);
    }
    for(int i=belong[x]+1;i<=belong[y]-1;i++){
        pos=lower_bound(w+l[i],w+r[i]+1,v-tag[i])-w;
        pos--;
        if(pos>=l[i]) res=max(res,w[pos]+tag[i]);
    }
    return res;
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++) w[i]=read(),t[i]=w[i];
    build();
    for(int i=1;i<=n;i++){
        int opt=read(),L=read(),R=read(),c=read();
        if(opt==0) add(L,R,c);
        else{
            int t=query(L,R,c);
            if(t==-1e15) puts("-1");
            else printf("%lld\n",t);
        }
    }
    return 0;
}
```

[LOJ数列分块5](https://loj.ac/problem/6281)：

给你一个序列，要求资瓷区间开方，区间求和。序列长度$<=50000$

做过[$GSS4$](https://www.luogu.org/problemnew/show/SP2713)，就知道做法了，只不过线段树改分块而已。

发现一个数开方最多开6次，当一段序列最大值为1，显然不需要再开方，分块维护区间和，区间最大值，当区间最大值大于1暴力开方。维护什么应该是基本操作：
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
using namespace std;
int n,w[50005],size,num,belong[50005],l[10005],r[10005],ma[10005],sum[10005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline void build(){
    size=sqrt(n);
    num=n/size;
    if(n%size) num++;
    for(int i=1;i<=n;i++){
        belong[i]=(i-1)/size+1;
        ma[belong[i]]=max(ma[belong[i]],w[i]);
        sum[belong[i]]+=w[i];
    }
    for(int i=1;i<=num;i++){
        l[i]=(i-1)*size+1;
        r[i]=i*size;
    }
    r[num]=n;
}
inline void sq(int x,int y){
    if(ma[belong[x]]>1){
        for(int i=x;i<=min(y,r[belong[x]]);i++){
            sum[belong[i]]-=w[i];
            w[i]=sqrt(w[i]);
            sum[belong[i]]+=w[i];
        }
        ma[belong[x]]=0;
        for(int i=l[belong[x]];i<=r[belong[x]];i++) ma[belong[x]]=max(ma[belong[x]],w[i]);
    }
    if(belong[x]!=belong[y]){
        if(ma[belong[y]]>1){
            for(int i=l[belong[y]];i<=y;i++){
                sum[belong[y]]-=w[i];
                w[i]=sqrt(w[i]);
                sum[belong[y]]+=w[i];
            }
            ma[belong[y]]=0;
            for(int i=l[belong[y]];i<=r[belong[y]];i++) ma[belong[y]]=max(ma[belong[y]],w[i]);
        }
    }
    for(int i=belong[x]+1;i<=belong[y]-1;i++){
        if(ma[i]>1){
            ma[i]=0;
            for(int j=l[i];j<=r[i];j++){
                sum[i]-=w[j];
                w[j]=sqrt(w[j]);
                ma[i]=max(ma[i],w[j]);
                sum[i]+=w[j];
            }
        }
    }
}
inline int query(int x,int y){
    int res=0;
    for(int i=x;i<=min(y,r[belong[x]]);i++) res+=w[i];
    if(belong[x]!=belong[y])
        for(int i=l[belong[y]];i<=y;i++)
            res+=w[i];
    for(int i=belong[x]+1;i<=belong[y]-1;i++) res+=sum[i];
    return res;
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++) w[i]=read();
    build();
    for(int i=1;i<=n;i++){
        int opt=read(),L=read(),R=read(),cccc=read();
        if(opt==0) sq(L,R);
        else printf("%lld\n",query(L,R));
    }
    return 0;
}
```
